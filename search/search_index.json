{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentaci\u00f3n del Proyecto Spring Demo","text":"<p>Bienvenido a la documentaci\u00f3n del proyecto Spring Demo. Aqu\u00ed encontrar\u00e1s informaci\u00f3n detallada sobre c\u00f3mo configurar, desarrollar y desplegar aplicaciones utilizando Spring Boot y sus m\u00f3dulos asociados.</p>"},{"location":"#indice","title":"\u00cdndice","text":"<ol> <li>Introducci\u00f3n a Spring Boot y conceptos clave</li> <li>Configuraci\u00f3n del Proyecto</li> <li>Introducci\u00f3n a Spring Web</li> <li>Gesti\u00f3n de Datos y L\u00f3gica de Negocio con Spring Data</li> <li>Seguridad con Spring Security y JWT</li> <li>Documentaci\u00f3n con Swagger</li> <li>Implementaci\u00f3n de Servicios en Red</li> </ol>"},{"location":"0_introduccion/","title":"Introducci\u00f3n a Spring Boot y conceptos clave","text":""},{"location":"0_introduccion/#indice","title":"\u00cdndice","text":"<ul> <li>Introducci\u00f3n a Spring Boot y conceptos clave</li> <li>\u00cdndice</li> <li>Introducci\u00f3n a Conceptos B\u00e1sicos de Spring<ul> <li>\u00bfQu\u00e9 es Spring?</li> <li>Framework vs. Librer\u00eda</li> <li>Historia de Spring</li> <li>Introducci\u00f3n a Spring Boot</li> <li>Caracter\u00edsticas principales</li> <li>Ejemplo pr\u00e1ctico: \"Hello World\"</li> <li>Uso de Spring Initializr</li> </ul> </li> <li>Principales Proyectos de Spring<ul> <li>Spring Boot</li> <li>Spring Web</li> <li>Caracter\u00edsticas principales</li> <li>Spring Data</li> <li>Caracter\u00edsticas principales</li> <li>Spring Security</li> <li>Caracter\u00edsticas principales</li> <li>Spring Cloud</li> <li>Caracter\u00edsticas principales</li> </ul> </li> <li>Material Avanzado<ul> <li>Configuraci\u00f3n Avanzada de Spring Boot</li> <li>Configuraci\u00f3n de Perfiles</li> <li>Configuraci\u00f3n de Propiedades Externas</li> <li>Monitoreo y M\u00e9tricas</li> <li>Habilitar Actuator</li> <li>Monitoreo de la Salud de la Aplicaci\u00f3n</li> <li>M\u00e9tricas de Rendimiento</li> <li>Explicaci\u00f3n del C\u00f3digo</li> <li>Beneficios de Usar Actuator</li> <li>Actividad Pr\u00e1ctica</li> </ul> </li> </ul>"},{"location":"0_introduccion/#introduccion-a-conceptos-basicos-de-spring","title":"Introducci\u00f3n a Conceptos B\u00e1sicos de Spring","text":""},{"location":"0_introduccion/#que-es-spring","title":"\u00bfQu\u00e9 es Spring?","text":"<p>Spring es un framework de c\u00f3digo abierto para el desarrollo de aplicaciones en Java que promueve buenas pr\u00e1cticas de dise\u00f1o. Su prop\u00f3sito principal es reducir la complejidad en la configuraci\u00f3n y el desarrollo de aplicaciones empresariales, permitiendo a los desarrolladores centrarse en la l\u00f3gica de negocio.</p> <p>Spring es muy vers\u00e1til y se puede usar para desarrollar aplicaciones de cualquier tipo, desde simples herramientas hasta sistemas empresariales complejos.</p>"},{"location":"0_introduccion/#framework-vs-libreria","title":"Framework vs. Librer\u00eda","text":"<p>Un framework como Spring establece un conjunto de reglas y estructuras que el desarrollador debe seguir, ofreciendo flexibilidad pero tambi\u00e9n direcci\u00f3n. A diferencia de una librer\u00eda, que simplemente provee funciones reutilizables, un framework como Spring organiza y gestiona el flujo de control de la aplicaci\u00f3n.</p>"},{"location":"0_introduccion/#historia-de-spring","title":"Historia de Spring","text":"<p>Spring fue creado en 2003 por Rod Johnson como una alternativa m\u00e1s sencilla y modular a las especificaciones complejas de Java EE. Su objetivo inicial era facilitar el desarrollo de aplicaciones empresariales al proporcionar un enfoque m\u00e1s ligero y flexible.</p>"},{"location":"0_introduccion/#introduccion-a-spring-boot","title":"Introducci\u00f3n a Spring Boot","text":"<p>Spring Boot es una extensi\u00f3n del framework Spring dise\u00f1ada para simplificar el desarrollo y despliegue de aplicaciones. Es ideal tanto para principiantes como para desarrolladores experimentados que deseen reducir la complejidad de configuraci\u00f3n.</p>"},{"location":"0_introduccion/#caracteristicas-principales","title":"Caracter\u00edsticas principales","text":"<ul> <li>Configuraci\u00f3n autom\u00e1tica: Spring Boot configura autom\u00e1ticamente los componentes necesarios en funci\u00f3n de las dependencias incluidas en el proyecto.</li> <li>Servidores embebidos: Integraci\u00f3n con servidores como Tomcat o Jetty, lo que elimina la necesidad de configurarlos externamente.</li> <li>Aplicaciones listas para producci\u00f3n: Incluye herramientas para monitoreo, m\u00e9tricas y an\u00e1lisis de rendimiento.</li> </ul>"},{"location":"0_introduccion/#ejemplo-practico-hello-world","title":"Ejemplo pr\u00e1ctico: \"Hello World\"","text":"<pre><code>@SpringBootApplication\npublic class HelloWorldApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(HelloWorldApplication.class, args);\n    }\n}\n</code></pre>"},{"location":"0_introduccion/#uso-de-spring-initializr","title":"Uso de Spring Initializr","text":"<p>Spring Initializr es una herramienta que permite generar proyectos Spring Boot con las dependencias necesarias. Aqu\u00ed se explica c\u00f3mo utilizar Spring Initializr para crear un nuevo proyecto:</p> <ol> <li>Acceder a Spring Initializr:</li> <li> <p>Abre un navegador web y navega a Spring Initializr.</p> </li> <li> <p>Configurar el Proyecto:</p> </li> <li>Selecciona las opciones de configuraci\u00f3n del proyecto, como el nombre del grupo, el nombre del artefacto, la versi\u00f3n de Java, etc.</li> <li> <p>A\u00f1ade las dependencias necesarias, como <code>Spring Web</code>, <code>Spring Data JPA</code>, <code>Spring Boot DevTools</code>, etc. Por ahora basta con Spring Web</p> </li> <li> <p>Generar el Proyecto:</p> </li> <li>Haz clic en el bot\u00f3n \"Generate\" para descargar el proyecto generado.</li> <li>Descomprime el archivo descargado y abre el proyecto en tu IDE favorito.</li> </ol>"},{"location":"0_introduccion/#principales-proyectos-de-spring","title":"Principales Proyectos de Spring","text":""},{"location":"0_introduccion/#spring-boot","title":"Spring Boot","text":"<p>Spring Boot es una herramienta que simplifica significativamente el desarrollo con Spring, eliminando la necesidad de configuraciones extensas y repetitivas. Est\u00e1 dise\u00f1ado para agilizar la creaci\u00f3n de aplicaciones listas para producci\u00f3n, especialmente en entornos de microservicios.</p>"},{"location":"0_introduccion/#spring-web","title":"Spring Web","text":"<p>Spring Web es un m\u00f3dulo de Spring que facilita la creaci\u00f3n de aplicaciones web y servicios RESTful. Proporciona soporte para controladores, vistas y modelos, y permite manejar solicitudes HTTP de manera sencilla.</p>"},{"location":"0_introduccion/#caracteristicas-principales_1","title":"Caracter\u00edsticas principales","text":"<ul> <li>Controladores RESTful: Facilita la creaci\u00f3n de APIs RESTful mediante anotaciones como <code>@RestController</code>.</li> <li>Manejo de solicitudes HTTP: Permite manejar solicitudes HTTP GET, POST, PUT, DELETE, etc.</li> <li>Soporte para vistas: Integra con tecnolog\u00edas de vistas como Thymeleaf, JSP, etc.</li> </ul>"},{"location":"0_introduccion/#spring-data","title":"Spring Data","text":"<p>Spring Data facilita la interacci\u00f3n con bases de datos mediante la definici\u00f3n de repositorios que encapsulan las operaciones CRUD y consultas personalizadas. Su objetivo es reducir la cantidad de c\u00f3digo repetitivo en las capas de acceso a datos.</p>"},{"location":"0_introduccion/#caracteristicas-principales_2","title":"Caracter\u00edsticas principales","text":"<ul> <li>Repositorios predefinidos: Proporciona interfaces como <code>JpaRepository</code> que permiten realizar operaciones est\u00e1ndar sin necesidad de implementaci\u00f3n manual.</li> <li>Consultas personalizadas: Permite definir consultas espec\u00edficas mediante nombres de m\u00e9todos o anotaciones como <code>@Query</code>.</li> <li>Compatibilidad con m\u00faltiples bases de datos: Incluye soporte para MySQL, PostgreSQL, MongoDB, Cassandra, entre otras.</li> <li>Auditor\u00eda: Proporciona soporte para auditor\u00eda de entidades, permitiendo rastrear cambios en los datos.</li> <li>Paginaci\u00f3n y ordenaci\u00f3n: Facilita la paginaci\u00f3n y ordenaci\u00f3n de resultados de consultas.</li> </ul>"},{"location":"0_introduccion/#spring-security","title":"Spring Security","text":"<p>Spring Security es un marco que proporciona herramientas avanzadas para garantizar la autenticaci\u00f3n, autorizaci\u00f3n y protecci\u00f3n contra ataques comunes en aplicaciones Java.</p>"},{"location":"0_introduccion/#caracteristicas-principales_3","title":"Caracter\u00edsticas principales","text":"<ul> <li>Gesti\u00f3n de roles y permisos: Controla el acceso a diferentes partes de la aplicaci\u00f3n seg\u00fan roles definidos.</li> <li>Protecci\u00f3n avanzada: Incluye medidas contra ataques de fuerza bruta, CSRF y XSS.</li> <li>Compatibilidad: Funciona con autenticaci\u00f3n tradicional basada en formularios y sistemas modernos como OAuth2 o JWT.</li> <li>Integraci\u00f3n con Spring Boot: Se integra f\u00e1cilmente con aplicaciones Spring Boot para proporcionar seguridad de manera r\u00e1pida y sencilla.</li> <li>Personalizaci\u00f3n: Permite personalizar la configuraci\u00f3n de seguridad seg\u00fan las necesidades espec\u00edficas de la aplicaci\u00f3n.</li> </ul>"},{"location":"0_introduccion/#spring-cloud","title":"Spring Cloud","text":"<p>Spring Cloud extiende las funcionalidades de Spring para abordar los desaf\u00edos de arquitecturas distribuidas y microservicios. Este marco se enfoca en la gesti\u00f3n de configuraci\u00f3n, descubrimiento de servicios, balanceo de carga y comunicaci\u00f3n entre servicios.</p>"},{"location":"0_introduccion/#caracteristicas-principales_4","title":"Caracter\u00edsticas principales","text":"<ul> <li>Gesti\u00f3n de configuraci\u00f3n: Centraliza la configuraci\u00f3n de aplicaciones distribuidas.</li> <li>Descubrimiento de servicios: Permite que los servicios se registren y descubran entre s\u00ed.</li> <li>Balanceo de carga: Distribuye el tr\u00e1fico de manera equitativa entre instancias de servicios.</li> <li>Comunicaci\u00f3n entre servicios: Facilita la comunicaci\u00f3n entre servicios mediante herramientas como Feign y Ribbon.</li> </ul>"},{"location":"0_introduccion/#material-avanzado","title":"Material Avanzado","text":""},{"location":"0_introduccion/#configuracion-avanzada-de-spring-boot","title":"Configuraci\u00f3n Avanzada de Spring Boot","text":"<p>Spring Boot permite configurar perfiles para gestionar diferentes configuraciones en distintos entornos (desarrollo, producci\u00f3n, etc.). Aqu\u00ed se explica c\u00f3mo configurar perfiles y propiedades externas.</p>"},{"location":"0_introduccion/#configuracion-de-perfiles","title":"Configuraci\u00f3n de Perfiles","text":"<ol> <li>Crear Archivos de Configuraci\u00f3n por Perfil:</li> <li>Crear archivos de configuraci\u00f3n espec\u00edficos para cada perfil, como <code>application-dev.properties</code> y <code>application-prod.properties</code>.</li> </ol> <p><code>properties    # application-dev.properties    server.port=8081    spring.datasource.url=jdbc:h2:mem:devdb</code></p> <p><code>properties    # application-prod.properties    server.port=8080    spring.datasource.url=jdbc:mysql://localhost/proddb</code></p> <ol> <li>Activar un Perfil:</li> <li>Activar un perfil espec\u00edfico utilizando la propiedad <code>spring.profiles.active</code> en el archivo <code>application.properties</code> o mediante una variable de entorno.</li> </ol> <p><code>properties    # application.properties    spring.profiles.active=dev</code></p>"},{"location":"0_introduccion/#configuracion-de-propiedades-externas","title":"Configuraci\u00f3n de Propiedades Externas","text":"<p>Spring Boot permite cargar propiedades desde archivos externos o variables de entorno.</p> <ol> <li>Cargar Propiedades desde un Archivo Externo:</li> <li>Especificar la ubicaci\u00f3n del archivo de propiedades externo utilizando la propiedad <code>spring.config.location</code>.</li> </ol> <p><code>properties    # application.properties    spring.config.location=classpath:/config/application-external.properties</code></p> <ol> <li>Utilizar Variables de Entorno:</li> <li>Definir variables de entorno en el sistema operativo y acceder a ellas en el archivo de configuraci\u00f3n.</li> </ol> <p><code>properties    # application.properties    spring.datasource.url=${DATASOURCE_URL}</code></p>"},{"location":"0_introduccion/#monitoreo-y-metricas","title":"Monitoreo y M\u00e9tricas","text":"<p>Spring Boot Actuator proporciona funcionalidades para monitorear y gestionar aplicaciones en producci\u00f3n. Aqu\u00ed se explica c\u00f3mo habilitar y configurar Actuator.</p>"},{"location":"0_introduccion/#habilitar-actuator","title":"Habilitar Actuator","text":"<ol> <li>Agregar la Dependencia de Actuator:</li> <li>A\u00f1adir la dependencia <code>spring-boot-starter-actuator</code> en el archivo <code>pom.xml</code>.</li> </ol> <p><code>xml    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;    &lt;/dependency&gt;</code></p> <ol> <li>Configurar Actuator:</li> <li>Configurar Actuator en el archivo <code>application.properties</code>.</li> </ol> <p><code>properties    management.endpoints.web.exposure.include=*    management.endpoint.health.show-details=always</code></p>"},{"location":"0_introduccion/#monitoreo-de-la-salud-de-la-aplicacion","title":"Monitoreo de la Salud de la Aplicaci\u00f3n","text":"<p>Actuator proporciona un endpoint <code>/actuator/health</code> para monitorear la salud de la aplicaci\u00f3n.</p> <ol> <li>Acceder al Endpoint de Salud:</li> <li>Iniciar la aplicaci\u00f3n Spring Boot.</li> <li>Acceder al endpoint de salud en <code>http://localhost:8080/actuator/health</code>.</li> </ol>"},{"location":"0_introduccion/#metricas-de-rendimiento","title":"M\u00e9tricas de Rendimiento","text":"<p>Actuator proporciona un endpoint <code>/actuator/metrics</code> para acceder a m\u00e9tricas de rendimiento.</p> <ol> <li>Acceder al Endpoint de M\u00e9tricas:</li> <li>Iniciar la aplicaci\u00f3n Spring Boot.</li> <li>Acceder al endpoint de m\u00e9tricas en <code>http://localhost:8080/actuator/metrics</code>.</li> </ol>"},{"location":"0_introduccion/#explicacion-del-codigo","title":"Explicaci\u00f3n del C\u00f3digo","text":"<ul> <li><code>spring.profiles.active</code>: Propiedad utilizada para activar un perfil espec\u00edfico.</li> <li><code>spring.config.location</code>: Propiedad utilizada para especificar la ubicaci\u00f3n de un archivo de propiedades externo.</li> <li><code>management.endpoints.web.exposure.include</code>: Propiedad utilizada para exponer todos los endpoints de Actuator.</li> <li><code>management.endpoint.health.show-details</code>: Propiedad utilizada para mostrar detalles en el endpoint de salud.</li> </ul>"},{"location":"0_introduccion/#beneficios-de-usar-actuator","title":"Beneficios de Usar Actuator","text":"<ul> <li>Monitoreo en Tiempo Real: Proporciona informaci\u00f3n en tiempo real sobre la salud y el rendimiento de la aplicaci\u00f3n.</li> <li>Gesti\u00f3n Simplificada: Facilita la gesti\u00f3n de aplicaciones en producci\u00f3n mediante endpoints de administraci\u00f3n.</li> <li>Integraci\u00f3n con Herramientas de Monitoreo: Se integra f\u00e1cilmente con herramientas de monitoreo como Prometheus y Grafana.</li> </ul>"},{"location":"0_introduccion/#actividad-practica","title":"Actividad Pr\u00e1ctica","text":"<ol> <li>Configurar Perfiles en Spring Boot:</li> <li>Crear archivos de configuraci\u00f3n espec\u00edficos para cada perfil.</li> <li> <p>Activar un perfil espec\u00edfico utilizando la propiedad <code>spring.profiles.active</code>.</p> </li> <li> <p>Habilitar y Configurar Actuator:</p> </li> <li>A\u00f1adir la dependencia <code>spring-boot-starter-actuator</code>.</li> <li>Configurar Actuator en el archivo <code>application.properties</code>.</li> <li>Acceder a los endpoints de salud y m\u00e9tricas para monitorear la aplicaci\u00f3n.</li> </ol>"},{"location":"1_configuracion/","title":"Configuraci\u00f3n del Proyecto","text":""},{"location":"1_configuracion/#capitulo-1-introduccion-a-spring-boot-y-configuracion-del-proyecto","title":"Cap\u00edtulo 1: Introducci\u00f3n a Spring Boot y Configuraci\u00f3n del Proyecto","text":""},{"location":"1_configuracion/#introduccion","title":"Introducci\u00f3n","text":"<p>Spring Boot es un framework que facilita la creaci\u00f3n de aplicaciones Java basadas en Spring. Proporciona configuraci\u00f3n autom\u00e1tica y servidores embebidos, lo que permite desarrollar aplicaciones r\u00e1pidamente.</p>"},{"location":"1_configuracion/#actividad-practica","title":"Actividad Pr\u00e1ctica","text":"<ol> <li>Crear un proyecto Spring Boot:</li> <li> <p>Utiliza Spring Initializr para crear un nuevo proyecto llamado \"spring-demo\" con las dependencias necesarias, por ejemplo, puedes a\u00f1adir Spring Web.</p> </li> <li> <p>Estructura del Proyecto y Explicaci\u00f3n de Componentes:</p> </li> <li> <p>src/main/java: Contiene el c\u00f3digo fuente de la aplicaci\u00f3n.</p> <ul> <li>com.example.springdemo: Paquete base donde se encuentra la clase principal.</li> <li>SpringDemoApplication.java: Clase principal de la aplicaci\u00f3n con la anotaci\u00f3n <code>@SpringBootApplication</code>.      ```java      @SpringBootApplication      public class SpringDemoApplication {          private static final Logger logger = LoggerFactory.getLogger(SpringDemoApplication.class);<pre><code> public static void main(String[] args) {\n     logger.info(\"Iniciando la aplicaci\u00f3n Spring Boot\");\n     SpringApplication.run(SpringDemoApplication.class, args);\n     logger.info(\"Aplicaci\u00f3n Spring Boot iniciada\");\n }\n</code></pre> <p>}  <code>La anotaci\u00f3n `@SpringBootApplication` es una combinaci\u00f3n de tres anotaciones: `@Configuration`, `@EnableAutoConfiguration`, y `@ComponentScan`. Esta anotaci\u00f3n marca la clase como la principal para la configuraci\u00f3n de Spring Boot. El m\u00e9todo `main` utiliza `SpringApplication.run` para lanzar la aplicaci\u00f3n.    - **src/main/resources**: Contiene recursos est\u00e1ticos y archivos de configuraci\u00f3n.      - **application.properties**: Archivo de configuraci\u00f3n de la aplicaci\u00f3n.</code>properties        # Configuraci\u00f3n de ejemplo        server.port=8080        spring.application.name=spring-demo        <code>El archivo `application.properties` se utiliza para configurar diversas propiedades de la aplicaci\u00f3n, como el puerto del servidor y el nombre de la aplicaci\u00f3n.    - **src/test/java**: Contiene las pruebas unitarias de la aplicaci\u00f3n.    - **pom.xml**: Archivo de configuraci\u00f3n de Maven que gestiona las dependencias del proyecto.</code>xml       org.springframework.boot spring-boot-starter-web <code>``      El archivo</code>pom.xml<code>es utilizado por Maven para gestionar las dependencias del proyecto. En este ejemplo, se incluye la dependencia</code>spring-boot-starter-web` para a\u00f1adir soporte para aplicaciones web.</p> </li> </ul> </li> <li> <p>Poner en ejecuci\u00f3n el proyecto:</p> </li> <li>Abre una terminal en el directorio ra\u00edz del proyecto.</li> <li>Ejecuta el siguiente comando para compilar y ejecutar la aplicaci\u00f3n:      <code>sh      ./mvnw spring-boot:run</code></li> <li>La aplicaci\u00f3n estar\u00e1 disponible en <code>http://localhost:8080</code>.</li> </ol>"},{"location":"1_configuracion/#uso-de-logger-en-spring-boot","title":"Uso de Logger en Spring Boot","text":"<p>El uso de un Logger es esencial para registrar eventos importantes y errores en la aplicaci\u00f3n. Spring Boot utiliza <code>SLF4J</code> como interfaz de registro y <code>Logback</code> como implementaci\u00f3n predeterminada. Aqu\u00ed se muestra c\u00f3mo configurar y usar un Logger en una clase de servicio:</p> <ol> <li> <p>Agregar la dependencia de SLF4J en <code>pom.xml</code>:    <code>xml    &lt;dependency&gt;        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;        &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;        &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;    &lt;/dependency&gt;</code></p> </li> <li> <p>Configurar el Logger en una clase de servicio:    ```java    import org.slf4j.Logger;    import org.slf4j.LoggerFactory;    import org.springframework.stereotype.Service;</p> </li> </ol> <p>@Service    public class ExampleService {        private static final Logger logger = LoggerFactory.getLogger(ExampleService.class);</p> <pre><code>   public void exampleMethod() {\n       logger.info(\"M\u00e9todo exampleMethod ejecutado\");\n       logger.debug(\"Debugging exampleMethod\");\n       try {\n           // ...existing code...\n       } catch (Exception e) {\n           logger.error(\"Error en exampleMethod: {}\", e.getMessage());\n       }\n   }\n</code></pre> <p>}    ```</p>"},{"location":"1_configuracion/#configuracion-de-niveles-de-registro-en-applicationproperties","title":"Configuraci\u00f3n de Niveles de Registro en <code>application.properties</code>","text":"<p>Para configurar diferentes niveles de registro (INFO, DEBUG, ERROR) en <code>application.properties</code>, se pueden a\u00f1adir las siguientes propiedades:</p> <pre><code>logging.level.root=INFO\nlogging.level.com.example.springdemo=DEBUG\nlogging.file.name=logs/spring-demo.log\n</code></pre>"},{"location":"1_configuracion/#ejemplos-de-pruebas-unitarias","title":"Ejemplos de Pruebas Unitarias","text":"<p>Las pruebas unitarias son esenciales para asegurar que el c\u00f3digo funcione correctamente y para detectar errores de manera temprana. Aqu\u00ed se muestra c\u00f3mo escribir y ejecutar pruebas unitarias en Spring Boot:</p> <ol> <li> <p>Agregar Dependencias de Pruebas en <code>pom.xml</code>:    <code>xml    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;</code></p> </li> <li> <p>Escribir una Prueba Unitaria para un Controlador:    ```java    import org.junit.jupiter.api.Test;    import org.springframework.beans.factory.annotation.Autowired;    import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;    import org.springframework.test.web.servlet.MockMvc;</p> </li> </ol> <p>import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;    import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;    import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</p> <p>@WebMvcTest(HolaMundoController.class)    public class HolaMundoControllerTest {</p> <pre><code>   @Autowired\n   private MockMvc mockMvc;\n\n   @Test\n   public void testHolaMundo() throws Exception {\n       mockMvc.perform(get(\"/api/hola\"))\n               .andExpect(status().isOk())\n               .andExpect(content().string(\"Hola Mundo\"));\n   }\n</code></pre> <p>}    ```</p> <ol> <li>Escribir una Prueba Unitaria para un Servicio:    ```java    import org.junit.jupiter.api.Test;    import org.springframework.beans.factory.annotation.Autowired;    import org.springframework.boot.test.context.SpringBootTest;</li> </ol> <p>import static org.assertj.core.api.Assertions.assertThat;</p> <p>@SpringBootTest    public class ExampleServiceTest {</p> <pre><code>   @Autowired\n   private ExampleService exampleService;\n\n   @Test\n   public void testExampleMethod() {\n       exampleService.exampleMethod();\n       // Verificar el comportamiento esperado\n       assertThat(true).isTrue();\n   }\n</code></pre> <p>}    ```</p>"},{"location":"1_configuracion/#explicacion-del-codigo","title":"Explicaci\u00f3n del C\u00f3digo","text":"<ul> <li><code>@SpringBootApplication</code>: Esta anotaci\u00f3n es una combinaci\u00f3n de tres anotaciones: <code>@Configuration</code>, <code>@EnableAutoConfiguration</code>, y <code>@ComponentScan</code>. Marca la clase como la principal para la configuraci\u00f3n de Spring Boot.</li> <li><code>SpringApplication.run(SpringDemoApplication.class, args)</code>: Este m\u00e9todo lanza la aplicaci\u00f3n Spring Boot.</li> <li><code>Logger</code>: Utilizado para registrar eventos importantes y errores en la aplicaci\u00f3n.</li> <li><code>@WebMvcTest</code>: Anotaci\u00f3n utilizada para pruebas unitarias de controladores.</li> <li><code>MockMvc</code>: Utilizado para realizar solicitudes HTTP simuladas en pruebas unitarias.</li> <li><code>@SpringBootTest</code>: Anotaci\u00f3n utilizada para pruebas unitarias de servicios.</li> </ul>"},{"location":"1_configuracion/#beneficios-de-usar-spring-boot","title":"Beneficios de Usar Spring Boot","text":"<ul> <li>Configuraci\u00f3n Autom\u00e1tica: Spring Boot configura autom\u00e1ticamente los componentes necesarios en funci\u00f3n de las dependencias incluidas en el proyecto.</li> <li>Servidores Embebidos: Integraci\u00f3n con servidores como Tomcat o Jetty, lo que elimina la necesidad de configurarlos externamente.</li> <li>Aplicaciones Listas para Producci\u00f3n: Incluye herramientas para monitoreo, m\u00e9tricas y an\u00e1lisis de rendimiento.</li> </ul>"},{"location":"1_configuracion/#actividad-practica_1","title":"Actividad Pr\u00e1ctica","text":"<ol> <li>Explorar la Estructura del Proyecto:</li> <li>Navegar por los directorios y archivos del proyecto para familiarizarse con la estructura del proyecto Spring Boot.</li> <li>Revisar el archivo <code>application.properties</code> y agregar configuraciones adicionales seg\u00fan sea necesario.</li> </ol>"},{"location":"1_configuracion/#posibles-errores-comunes","title":"Posibles Errores Comunes","text":"<ol> <li>Error de Conexi\u00f3n al Servidor:</li> <li> <p>Soluci\u00f3n: Verificar que el puerto configurado en <code>application.properties</code> no est\u00e9 en uso por otra aplicaci\u00f3n.</p> </li> <li> <p>Dependencias:</p> </li> <li>Soluci\u00f3n: Asegurarse de que todas las dependencias necesarias est\u00e9n incluidas en el archivo <code>pom.xml</code> y ejecutar <code>mvn clean install</code> para actualizar el proyecto.</li> </ol>"},{"location":"2_spring_web/","title":"Introducci\u00f3n a Spring Web","text":""},{"location":"2_spring_web/#capitulo-2-introduccion-a-spring-web","title":"Cap\u00edtulo 2: Introducci\u00f3n a Spring Web","text":""},{"location":"2_spring_web/#introduccion","title":"Introducci\u00f3n","text":"<p>Spring Web es un m\u00f3dulo de Spring que facilita la creaci\u00f3n de aplicaciones web y servicios RESTful. Proporciona soporte para controladores, vistas y modelos, y permite manejar solicitudes HTTP de manera sencilla.</p>"},{"location":"2_spring_web/#principales-anotaciones","title":"Principales Anotaciones","text":"<ul> <li>@RestController: Indica que la clase es un controlador RESTful.</li> <li>@RequestMapping: Mapea solicitudes HTTP a m\u00e9todos espec\u00edficos en un controlador.</li> <li>@GetMapping: Maneja solicitudes HTTP GET.</li> <li>@PostMapping: Maneja solicitudes HTTP POST.</li> <li>@PutMapping: Maneja solicitudes HTTP PUT.</li> <li>@DeleteMapping: Maneja solicitudes HTTP DELETE.</li> <li>@PathVariable: Vincula una variable de ruta a un par\u00e1metro de m\u00e9todo.</li> <li>@RequestParam: Vincula un par\u00e1metro de solicitud a un par\u00e1metro de m\u00e9todo.</li> <li>@RequestBody: Vincula el cuerpo de una solicitud a un par\u00e1metro de m\u00e9todo.</li> </ul>"},{"location":"2_spring_web/#ejemplos-de-anotaciones","title":"Ejemplos de Anotaciones","text":"<pre><code>@RestController\n@RequestMapping(\"/api\")\npublic class ExampleController {\n    private static final Logger logger = LoggerFactory.getLogger(ExampleController.class);\n\n    @GetMapping(\"/hello\")\n    public String sayHello() {\n        logger.info(\"sayHello endpoint llamado\");\n        return \"Hello, World!\";\n    }\n\n    @RequestMapping(value = \"/greet\", method = RequestMethod.GET)\n    public String greet() {\n        logger.info(\"greet endpoint llamado\");\n        return \"Greetings!\";\n    }\n\n    @PostMapping(\"/create\")\n    public String create(@RequestBody String data) {\n        logger.info(\"create endpoint llamado con datos: {}\", data);\n        return \"Data created: \" + data;\n    }\n\n    @PutMapping(\"/update\")\n    public String update(@RequestBody String data) {\n        logger.info(\"update endpoint llamado con datos: {}\", data);\n        return \"Data updated: \" + data;\n    }\n\n    @DeleteMapping(\"/delete/{id}\")\n    public String delete(@PathVariable Long id) {\n        logger.info(\"delete endpoint llamado con id: {}\", id);\n        return \"Data deleted with id: \" + id;\n    }\n\n    @GetMapping(\"/user/{id}\")\n    public String getUser(@PathVariable Long id) {\n        logger.info(\"getUser endpoint llamado con id: {}\", id);\n        return \"User ID: \" + id;\n    }\n\n    @GetMapping(\"/search\")\n    public String search(@RequestParam String query) {\n        logger.info(\"search endpoint llamado con query: {}\", query);\n        return \"Search query: \" + query;\n    }\n\n    @PostMapping(\"/add\")\n    public String add(@RequestBody String data) {\n        logger.info(\"add endpoint llamado con datos: {}\", data);\n        return \"Data added: \" + data;\n    }\n}\n</code></pre>"},{"location":"2_spring_web/#explicacion-del-codigo","title":"Explicaci\u00f3n del C\u00f3digo","text":"<ul> <li><code>@RestController</code>: Indica que la clase es un controlador RESTful.</li> <li><code>@RequestMapping</code>: Mapea solicitudes HTTP a m\u00e9todos espec\u00edficos en un controlador.</li> <li><code>@GetMapping</code>: Maneja solicitudes HTTP GET.</li> <li><code>@PostMapping</code>: Maneja solicitudes HTTP POST.</li> <li><code>@PutMapping</code>: Maneja solicitudes HTTP PUT.</li> <li><code>@DeleteMapping</code>: Maneja solicitudes HTTP DELETE.</li> <li><code>@PathVariable</code>: Vincula una variable de ruta a un par\u00e1metro de m\u00e9todo.</li> <li><code>@RequestParam</code>: Vincula un par\u00e1metro de solicitud a un par\u00e1metro de m\u00e9todo.</li> <li><code>@RequestBody</code>: Vincula el cuerpo de una solicitud a un par\u00e1metro de m\u00e9todo.</li> <li><code>Logger</code>: Utilizado para registrar eventos importantes y errores en la aplicaci\u00f3n.</li> </ul>"},{"location":"2_spring_web/#actividad-practica","title":"Actividad Pr\u00e1ctica","text":"<ol> <li>Crear un servicio REST \"Hola Mundo\":</li> <li>Crear un controlador RESTful que maneje una solicitud GET y devuelva un mensaje \"Hola Mundo\".</li> </ol> <p>```java    @RestController    @RequestMapping(\"/api\")    public class HolaMundoController {        private static final Logger logger = LoggerFactory.getLogger(HolaMundoController.class);</p> <pre><code>   @GetMapping(\"/hola\")\n   public String holaMundo() {\n       logger.info(\"holaMundo endpoint llamado\");\n       return \"Hola Mundo\";\n   }\n</code></pre> <p>}    ```</p>"},{"location":"2_spring_web/#ejemplo-practico","title":"Ejemplo Pr\u00e1ctico","text":"<ol> <li>Crear un controlador RESTful que maneje una solicitud POST con par\u00e1metros y cuerpo:</li> <li>Crear un controlador RESTful que maneje una solicitud POST, reciba par\u00e1metros en la URL y un cuerpo en la solicitud.</li> </ol> <p>```java    @RestController    @RequestMapping(\"/api\")    public class ComplexController {        private static final Logger logger = LoggerFactory.getLogger(ComplexController.class);</p> <pre><code>   @PostMapping(\"/process\")\n   public ResponseEntity&lt;String&gt; processRequest(\n           @RequestParam String param,\n           @RequestBody Map&lt;String, Object&gt; body) {\n       logger.info(\"processRequest endpoint llamado con param: {} y body: {}\", param, body);\n       String response = \"Received param: \" + param + \" and body: \" + body.toString();\n       return ResponseEntity.ok(response);\n   }\n</code></pre> <p>}    ```</p>"},{"location":"2_spring_web/#explicacion-del-codigo_1","title":"Explicaci\u00f3n del C\u00f3digo","text":"<ul> <li><code>@RestController</code>: Indica que la clase es un controlador RESTful.</li> <li><code>@RequestMapping(\"/api\")</code>: Mapea las solicitudes HTTP a la ruta base <code>/api</code>.</li> <li><code>@PostMapping(\"/process\")</code>: Maneja las solicitudes HTTP POST a la ruta <code>/api/process</code>.</li> <li><code>@RequestParam String param</code>: Vincula un par\u00e1metro de solicitud a un par\u00e1metro de m\u00e9todo.</li> <li><code>@RequestBody Map&lt;String, Object&gt; body</code>: Vincula el cuerpo de una solicitud a un par\u00e1metro de m\u00e9todo.</li> <li><code>ResponseEntity&lt;String&gt;</code>: Representa la respuesta HTTP con un cuerpo de tipo <code>String</code>.</li> <li><code>Logger</code>: Utilizado para registrar eventos importantes y errores en la aplicaci\u00f3n.</li> </ul>"},{"location":"2_spring_web/#actividad-practica_1","title":"Actividad Pr\u00e1ctica","text":"<ol> <li>Probar el Controlador RESTful:</li> <li>Iniciar la aplicaci\u00f3n Spring Boot.</li> <li>Utilizar una herramienta como Postman para enviar una solicitud POST a <code>http://localhost:8080/api/process</code> con un par\u00e1metro <code>param</code> y un cuerpo JSON.</li> <li>Verificar que la respuesta incluya tanto el par\u00e1metro como el cuerpo de la solicitud.</li> </ol>"},{"location":"2_spring_web/#beneficios-de-usar-spring-web","title":"Beneficios de Usar Spring Web","text":"<ul> <li>Facilidad de Uso: Spring Web proporciona anotaciones que simplifican la creaci\u00f3n de controladores y el manejo de solicitudes HTTP.</li> <li>Flexibilidad: Permite manejar diferentes tipos de solicitudes HTTP (GET, POST, PUT, DELETE) y vincular par\u00e1metros de solicitud y variables de ruta a m\u00e9todos de controlador.</li> <li>Integraci\u00f3n con Spring Boot: Se integra f\u00e1cilmente con aplicaciones Spring Boot, lo que facilita su configuraci\u00f3n y uso.</li> </ul>"},{"location":"2_spring_web/#actividad-practica_2","title":"Actividad Pr\u00e1ctica","text":"<ol> <li>Probar el Servicio REST \"Hola Mundo\":</li> <li>Iniciar la aplicaci\u00f3n Spring Boot.</li> <li>Utilizar un navegador web o una herramienta como Postman para enviar una solicitud GET a <code>http://localhost:8080/api/hola</code>.</li> <li>Verificar que la respuesta sea \"Hola Mundo\".</li> </ol>"},{"location":"2_spring_web/#validaciones-en-spring-boot","title":"Validaciones en Spring Boot","text":""},{"location":"2_spring_web/#introduccion-a-las-validaciones-en-spring-boot","title":"Introducci\u00f3n a las Validaciones en Spring Boot","text":"<p>Spring Boot proporciona soporte para validaciones utilizando la especificaci\u00f3n Bean Validation (JSR 380). Esto permite validar datos de entrada en controladores, servicios y entidades de manera sencilla y declarativa.</p>"},{"location":"2_spring_web/#configuracion-de-dependencias","title":"Configuraci\u00f3n de Dependencias","text":"<p>Para utilizar las validaciones en Spring Boot, es necesario a\u00f1adir la dependencia <code>spring-boot-starter-validation</code> en el archivo <code>pom.xml</code>:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"2_spring_web/#validaciones-en-entidades","title":"Validaciones en Entidades","text":"<p>Las validaciones se pueden aplicar a las entidades utilizando anotaciones como <code>@NotNull</code>, <code>@Size</code>, <code>@Email</code>, entre otras. Aqu\u00ed hay un ejemplo de c\u00f3mo aplicar validaciones a una entidad <code>User</code>:</p> <pre><code>@Entity\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n\n    @NotNull(message = \"El nombre de usuario no puede ser nulo\")\n    @Size(min = 3, max = 50, message = \"El nombre de usuario debe tener entre 3 y 50 caracteres\")\n    private String userName;\n\n    @NotNull(message = \"La contrase\u00f1a no puede ser nula\")\n    @Size(min = 6, message = \"La contrase\u00f1a debe tener al menos 6 caracteres\")\n    private String password;\n\n    @NotNull(message = \"El rol no puede ser nulo\")\n    private String role;\n\n    // Getters y setters...\n}\n</code></pre>"},{"location":"2_spring_web/#validaciones-en-controladores","title":"Validaciones en Controladores","text":"<p>Las validaciones se pueden aplicar a los datos de entrada en los controladores utilizando la anotaci\u00f3n <code>@Valid</code>. Aqu\u00ed hay un ejemplo de c\u00f3mo validar un objeto <code>User</code> en un controlador:</p> <pre><code>@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    private static final Logger logger = LoggerFactory.getLogger(UserController.class);\n\n    @Autowired\n    private UserService userService;\n\n    @PostMapping\n    public ResponseEntity&lt;User&gt; createUser(@Valid @RequestBody User user, BindingResult result) {\n        logger.info(\"createUser endpoint llamado con datos: {}\", user);\n        if (result.hasErrors()) {\n            logger.error(\"Errores de validaci\u00f3n: {}\", result.getAllErrors());\n            return ResponseEntity.badRequest().body(null);\n        }\n        User savedUser = userService.saveUser(user);\n        return ResponseEntity.ok(savedUser);\n    }\n}\n</code></pre>"},{"location":"2_spring_web/#validaciones-en-servicios","title":"Validaciones en Servicios","text":"<p>Las validaciones tambi\u00e9n se pueden aplicar en los servicios utilizando la anotaci\u00f3n <code>@Validated</code>. Aqu\u00ed hay un ejemplo de c\u00f3mo validar un objeto <code>User</code> en un servicio:</p> <pre><code>@Service\n@Validated\npublic class UserService {\n    private static final Logger logger = LoggerFactory.getLogger(UserService.class);\n\n    @Autowired\n    private UserRepository userRepository;\n\n    public User saveUser(@Valid User user) {\n        logger.info(\"Guardando usuario: {}\", user.getUserName());\n        return userRepository.save(user);\n    }\n}\n</code></pre>"},{"location":"2_spring_web/#explicacion-del-codigo_2","title":"Explicaci\u00f3n del C\u00f3digo","text":"<ul> <li><code>@NotNull</code>, <code>@Size</code>, <code>@Email</code>: Anotaciones de validaci\u00f3n que se utilizan para validar los campos de una entidad.</li> <li><code>@Valid</code>: Anotaci\u00f3n que se utiliza para validar un objeto en un controlador o servicio.</li> <li><code>BindingResult</code>: Objeto que contiene los resultados de la validaci\u00f3n.</li> <li><code>@Validated</code>: Anotaci\u00f3n que se utiliza para habilitar la validaci\u00f3n en un servicio.</li> <li><code>Logger</code>: Utilizado para registrar eventos importantes y errores en la aplicaci\u00f3n.</li> </ul>"},{"location":"2_spring_web/#beneficios-de-usar-validaciones-en-spring-boot","title":"Beneficios de Usar Validaciones en Spring Boot","text":"<ul> <li>Simplicidad: Las validaciones se pueden aplicar de manera declarativa utilizando anotaciones.</li> <li>Reutilizaci\u00f3n: Las reglas de validaci\u00f3n se pueden reutilizar en diferentes capas de la aplicaci\u00f3n.</li> <li>Consistencia: Las validaciones aseguran que los datos de entrada cumplan con las reglas definidas, mejorando la consistencia de los datos.</li> </ul>"},{"location":"2_spring_web/#actividad-practica_3","title":"Actividad Pr\u00e1ctica","text":"<ol> <li>Aplicar Validaciones a una Entidad:</li> <li>A\u00f1adir anotaciones de validaci\u00f3n a la entidad <code>User</code>.</li> <li>Crear un controlador y un servicio que utilicen las validaciones.</li> <li>Probar las validaciones utilizando una herramienta como Postman.</li> </ol>"},{"location":"2_spring_web/#posibles-errores-comunes","title":"Posibles Errores Comunes","text":"<ol> <li>Errores de Validaci\u00f3n:</li> <li> <p>Soluci\u00f3n: Verificar que los datos de entrada cumplen con las reglas de validaci\u00f3n definidas en las anotaciones.</p> </li> <li> <p>Dependencias:</p> </li> <li>Soluci\u00f3n: Asegurarse de que la dependencia <code>spring-boot-starter-validation</code> est\u00e9 incluida en el archivo <code>pom.xml</code> y ejecutar <code>mvn clean install</code> para actualizar el proyecto.</li> </ol>"},{"location":"3_spring_data/","title":"Gesti\u00f3n de Datos y L\u00f3gica de Negocio con Spring Data","text":""},{"location":"3_spring_data/#capitulo-3-gestion-de-datos-y-logica-de-negocio-con-spring-data","title":"Cap\u00edtulo 3: Gesti\u00f3n de Datos y L\u00f3gica de Negocio con Spring Data","text":""},{"location":"3_spring_data/#introduccion","title":"Introducci\u00f3n","text":"<p>JPA (Java Persistence API) es una especificaci\u00f3n para el acceso, persistencia y gesti\u00f3n de datos entre aplicaciones Java y bases de datos relacionales. Hibernate es una implementaci\u00f3n de JPA. Spring Data facilita la interacci\u00f3n con bases de datos mediante la definici\u00f3n de repositorios que encapsulan las operaciones CRUD y consultas personalizadas.</p>"},{"location":"3_spring_data/#modelado-de-datos-con-entidades","title":"Modelado de Datos con Entidades","text":"<p>Las entidades representan las tablas de la base de datos en el c\u00f3digo Java. Cada entidad se mapea a una tabla en la base de datos y sus atributos se mapean a las columnas de la tabla.</p>"},{"location":"3_spring_data/#estrategias-de-generacion-de-claves-primarias","title":"Estrategias de Generaci\u00f3n de Claves Primarias","text":"<p>JPA proporciona varias estrategias para la generaci\u00f3n de claves primarias:</p> <ul> <li>AUTO: JPA elige autom\u00e1ticamente la estrategia de generaci\u00f3n de claves m\u00e1s adecuada para la base de datos.</li> <li>IDENTITY: Utiliza una columna de identidad en la base de datos para generar las claves primarias.</li> <li>SEQUENCE: Utiliza una secuencia en la base de datos para generar las claves primarias.</li> <li>TABLE: Utiliza una tabla especial en la base de datos para generar las claves primarias.</li> </ul> <p>Ejemplo de configuraci\u00f3n de estrategias de generaci\u00f3n de claves primarias:</p> <pre><code>@Entity\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n\n    // ...existing code...\n}\n</code></pre>"},{"location":"3_spring_data/#relaciones-entre-entidades","title":"Relaciones entre Entidades","text":"<p>JPA permite definir relaciones entre entidades utilizando anotaciones como <code>@OneToMany</code>, <code>@ManyToOne</code>, <code>@OneToOne</code> y <code>@ManyToMany</code>.</p> <p>Ejemplo de relaciones entre entidades:</p> <pre><code>@Entity\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n\n    @OneToMany(mappedBy = \"user\")\n    private List&lt;Order&gt; orders;\n\n    // ...existing code...\n}\n\n@Entity\npublic class Order {\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n\n    @ManyToOne\n    @JoinColumn(name = \"user_id\")\n    private User user;\n\n    // ...existing code...\n}\n</code></pre>"},{"location":"3_spring_data/#consultas-personalizadas-con-query","title":"Consultas Personalizadas con @Query","text":"<p>Adem\u00e1s de las operaciones CRUD est\u00e1ndar, Spring Data JPA permite definir consultas personalizadas utilizando la anotaci\u00f3n <code>@Query</code>. Aqu\u00ed hay un ejemplo de c\u00f3mo definir y utilizar consultas personalizadas en un repositorio:</p> <ol> <li> <p>Definir una Consulta Personalizada:    ```java    @Repository    public interface UserRepository extends JpaRepository {        Optional findByUserName(String userName); <p>@Query(\"SELECT u FROM User u WHERE u.role = :role\")    List findUsersByRole(@Param(\"role\") String role); <p>@Query(\"SELECT u FROM User u WHERE u.userName LIKE %:userName%\")    List findUsersByUserNameContaining(@Param(\"userName\") String userName);    }    ``` <p>En este ejemplo:    - <code>@Query(\"SELECT u FROM User u WHERE u.role = :role\")</code>: Define una consulta personalizada que selecciona usuarios por su rol.    - <code>@Query(\"SELECT u FROM User u WHERE u.userName LIKE %:userName%\")</code>: Define una consulta personalizada que selecciona usuarios cuyo nombre de usuario contiene una cadena espec\u00edfica.    - <code>@Param(\"role\")</code> y <code>@Param(\"userName\")</code>: Vinculan los par\u00e1metros de la consulta a los par\u00e1metros del m\u00e9todo.</p> <ol> <li> <p>Utilizar la Consulta Personalizada en un Servicio:    ```java    @Service    public class UserService {        private static final Logger logger = LoggerFactory.getLogger(UserService.class);</p> <p>@Autowired    private UserRepository userRepository;</p> <p>public List getUsersByRole(String role) {        logger.info(\"Buscando usuarios con rol: {}\", role);        return userRepository.findUsersByRole(role);    } <p>public List getUsersByUserNameContaining(String userName) {        logger.info(\"Buscando usuarios cuyo nombre contiene: {}\", userName);        return userRepository.findUsersByUserNameContaining(userName);    }    }    ``` <p>En este ejemplo:    - <code>getUsersByRole(String role)</code>: M\u00e9todo del servicio que utiliza la consulta personalizada para obtener usuarios por su rol.    - <code>getUsersByUserNameContaining(String userName)</code>: M\u00e9todo del servicio que utiliza la consulta personalizada para obtener usuarios cuyo nombre de usuario contiene una cadena espec\u00edfica.    - <code>Logger</code>: Utilizado para registrar eventos importantes y errores en la aplicaci\u00f3n.</p>"},{"location":"3_spring_data/#consultas-nativas-y-criteria-api","title":"Consultas Nativas y Criteria API","text":"<p>Spring Data JPA permite definir consultas nativas y utilizar Criteria API para consultas din\u00e1micas.</p> <ol> <li> <p>Consultas Nativas:    <code>java    @Repository    public interface UserRepository extends JpaRepository&lt;User, Long&gt; {        @Query(value = \"SELECT * FROM users WHERE role = ?1\", nativeQuery = true)        List&lt;User&gt; findUsersByRoleNative(String role);    }</code></p> </li> <li> <p>Criteria API:    ```java    @Service    public class UserService {        @PersistenceContext        private EntityManager entityManager;</p> <p>public List findUsersByCriteria(String role) {        CriteriaBuilder cb = entityManager.getCriteriaBuilder();        CriteriaQuery query = cb.createQuery(User.class);        Root user = query.from(User.class);        query.select(user).where(cb.equal(user.get(\"role\"), role));        return entityManager.createQuery(query).getResultList();    }    }    ```"},{"location":"3_spring_data/#explicacion-del-codigo","title":"Explicaci\u00f3n del C\u00f3digo","text":"<ul> <li><code>@Entity</code>: Indica que la clase es una entidad JPA.</li> <li><code>@GeneratedValue(strategy = GenerationType.AUTO)</code>: Configura la estrategia de generaci\u00f3n de claves primarias.</li> <li><code>@OneToMany</code>, <code>@ManyToOne</code>: Define relaciones entre entidades.</li> <li><code>@Query</code>: Define consultas personalizadas.</li> <li><code>CriteriaBuilder</code>, <code>CriteriaQuery</code>: Utilizados para crear consultas din\u00e1micas con Criteria API.</li> </ul>"},{"location":"3_spring_data/#beneficios-de-usar-spring-data-jpa","title":"Beneficios de Usar Spring Data JPA","text":"<ul> <li>Simplicidad: Spring Data JPA simplifica la interacci\u00f3n con bases de datos mediante la definici\u00f3n de repositorios y consultas personalizadas.</li> <li>Flexibilidad: Permite definir consultas personalizadas utilizando JPQL, consultas nativas y Criteria API.</li> </ul>"},{"location":"3_spring_data/#actividad-practica","title":"Actividad Pr\u00e1ctica","text":"<ol> <li>Definir Consultas Personalizadas:</li> <li>A\u00f1adir consultas personalizadas en el repositorio <code>UserRepository</code>.</li> <li>Utilizar las consultas personalizadas en el servicio <code>UserService</code>.</li> <li>Probar las consultas personalizadas utilizando una herramienta como Postman.</li> </ol>"},{"location":"3_spring_data/#logica-de-negocio-en-servicios","title":"L\u00f3gica de Negocio en Servicios","text":"<p>Los servicios contienen la l\u00f3gica de negocio de la aplicaci\u00f3n y se implementan utilizando la anotaci\u00f3n <code>@Service</code>. Los servicios interact\u00faan con los repositorios para realizar operaciones en la base de datos.</p>"},{"location":"3_spring_data/#actividad-practica-integrada","title":"Actividad Pr\u00e1ctica Integrada","text":""},{"location":"3_spring_data/#configuracion-de-la-base-de-datos-local","title":"Configuraci\u00f3n de la Base de Datos Local","text":"<p>Antes de probar el repositorio, es necesario configurar una base de datos local. A continuaci\u00f3n, se muestran los pasos para configurar una base de datos MariaDB utilizando Docker:</p> <ol> <li>Instalar Docker:</li> <li> <p>Seguir las instrucciones de instalaci\u00f3n en Docker Downloads.</p> </li> <li> <p>Configurar y ejecutar el contenedor MariaDB:</p> </li> <li>Clonar el repositorio que contiene el archivo <code>docker-compose.yml</code>:      <code>sh      git clone https://github.com/jibanezmico/DockerUtils.git      cd DockerUtils/MariaDB</code></li> <li> <p>Ejecutar el contenedor:      <code>sh      docker-compose up -d</code></p> </li> <li> <p>Verificar que el contenedor est\u00e1 en ejecuci\u00f3n:</p> </li> <li> <p>Usar el comando <code>docker ps</code> para asegurarse de que el contenedor MariaDB est\u00e1 en ejecuci\u00f3n.</p> </li> <li> <p>Configurar el archivo <code>application.properties</code>:    <code>properties    spring.datasource.url=jdbc:mariadb://localhost:3306/demo_db    spring.datasource.username=mariadbuser    spring.datasource.password=mariadbpass    spring.datasource.driver-class-name=org.mariadb.jdbc.Driver    spring.jpa.hibernate.ddl-auto=update</code></p> </li> <li> <p>Probar la conexi\u00f3n:</p> </li> <li> <p>Ejecutar la aplicaci\u00f3n Spring Boot y verificar que se conecta correctamente a la base de datos.</p> </li> <li> <p>Crear la entidad <code>User</code>:    ```java    @Entity    public class User {        @Id        @GeneratedValue(strategy = GenerationType.AUTO)        private Long id;</p> <p>@NotNull(message = \"El nombre de usuario no puede ser nulo\")    @Size(min = 3, max = 50, message = \"El nombre de usuario debe tener entre 3 y 50 caracteres\")    private String userName;</p> <p>@NotNull(message = \"La contrase\u00f1a no puede ser nula\")    @Size(min = 6, message = \"La contrase\u00f1a debe tener al menos 6 caracteres\")    private String password;</p> <p>@NotNull(message = \"El rol no puede ser nulo\")    private String role;</p> <p>// Getters y setters...    }    <code>``    Esta clase</code>User<code>representa una entidad en la base de datos. La anotaci\u00f3n</code>@Entity<code>indica que esta clase es una entidad JPA. La anotaci\u00f3n</code>@Id<code>se utiliza para especificar el identificador de la entidad, y</code>@GeneratedValue` se utiliza para generar autom\u00e1ticamente el valor del identificador.</p> </li> <li> <p>Crear el repositorio <code>UserRepository</code>:    ```java    @Repository    public interface UserRepository extends JpaRepository {        Optional findByUserName(String userName); <p>@Query(\"SELECT u FROM User u WHERE u.role = :role\")    List findUsersByRole(@Param(\"role\") String role); <p>@Query(\"SELECT u FROM User u WHERE u.userName LIKE %:userName%\")    List findUsersByUserNameContaining(@Param(\"userName\") String userName);    }    <code>``    Esta interfaz</code>UserRepository<code>extiende</code>JpaRepository<code>, lo que proporciona m\u00e9todos CRUD est\u00e1ndar para la entidad</code>User<code>. Adem\u00e1s, se define un m\u00e9todo personalizado</code>findByUserName<code>para buscar usuarios por nombre de usuario y consultas personalizadas</code>findUsersByRole<code>y</code>findUsersByUserNameContaining` para buscar usuarios por rol y por nombre de usuario, respectivamente. <li> <p>Configurar el archivo <code>application.properties</code>:    <code>properties    spring.datasource.url=jdbc:mariadb://localhost:3306/demo_db    spring.datasource.username=mariadbuser    spring.datasource.password=mariadbpass    spring.datasource.driver-class-name=org.mariadb.jdbc.Driver    spring.jpa.hibernate.ddl-auto=update</code>    Este archivo <code>application.properties</code> contiene la configuraci\u00f3n de la base de datos. Se especifica la URL de la base de datos, el nombre de usuario, la contrase\u00f1a y el controlador JDBC. La propiedad <code>spring.jpa.hibernate.ddl-auto=update</code> indica que Hibernate debe actualizar el esquema de la base de datos en funci\u00f3n de las entidades definidas.</p> </li> <li> <p>Crear el servicio <code>UserService</code>:    ```java    @Service    @Validated    public class UserService implements UserDetailsService {        private static final Logger logger = LoggerFactory.getLogger(UserService.class);</p> <p>@Autowired    private UserRepository userRepository;</p> <p>@Override    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {        logger.info(\"Cargando usuario por nombre de usuario: {}\", username);        User user = userRepository.findByUserName(username)            .orElseThrow(() -&gt; new UsernameNotFoundException(\"Usuario no encontrado\"));        logger.info(\"Usuario encontrado: {}\", username);        return new org.springframework.security.core.userdetails.User(            user.getUserName(),            user.getPassword(),            Collections.singleton(new SimpleGrantedAuthority(\"ROLE_\" + user.getRole()))        );    }</p> <p>public List getAllUsers() {        logger.info(\"Obteniendo todos los usuarios\");        return userRepository.findAll();    } <p>public User saveUser(@Valid User user) {        logger.info(\"Guardando usuario: {}\", user.getUserName());        logger.debug(\"Datos del usuario: {}\", user);        return userRepository.save(user);    }</p> <p>public Optional getByUserName(String userName) {        logger.info(\"Buscando usuario por nombre de usuario: {}\", userName);        return userRepository.findByUserName(userName);    } <p>public List getUsersByRole(String role) {        logger.info(\"Buscando usuarios con rol: {}\", role);        return userRepository.findUsersByRole(role);    } <p>public List getUsersByUserNameContaining(String userName) {        logger.info(\"Buscando usuarios cuyo nombre contiene: {}\", userName);        return userRepository.findUsersByUserNameContaining(userName);    }    }    ``` <p>Esta clase <code>UserService</code> implementa <code>UserDetailsService</code> para proporcionar detalles de usuario a Spring Security. El m\u00e9todo <code>loadUserByUsername</code> carga un usuario por nombre de usuario y lanza una excepci\u00f3n si el usuario no se encuentra. Adem\u00e1s, se proporcionan m\u00e9todos para obtener todos los usuarios, guardar un usuario, buscar un usuario por nombre de usuario, buscar usuarios por rol y buscar usuarios cuyo nombre de usuario contiene una cadena espec\u00edfica. Se utiliza un Logger para registrar eventos importantes y se aplican validaciones a la entidad <code>User</code>.</p>"},{"location":"3_spring_data/#material-avanzado","title":"Material Avanzado","text":""},{"location":"3_spring_data/#auditoria-en-spring-data-jpa","title":"Auditor\u00eda en Spring Data JPA","text":"<p>Spring Data JPA proporciona soporte para auditor\u00eda de entidades, permitiendo rastrear cambios en los datos. Para habilitar la auditor\u00eda, se deben seguir los siguientes pasos:</p> <ol> <li>Habilitar la Auditor\u00eda:</li> <li>A\u00f1adir la anotaci\u00f3n <code>@EnableJpaAuditing</code> en una clase de configuraci\u00f3n.</li> </ol> <p><code>java    @Configuration    @EnableJpaAuditing    public class JpaConfig {        // ...existing code...    }</code></p> <ol> <li>Configurar las Entidades para Auditor\u00eda:</li> <li>A\u00f1adir las anotaciones <code>@CreatedDate</code>, <code>@LastModifiedDate</code>, <code>@CreatedBy</code> y <code>@LastModifiedBy</code> en las entidades.</li> </ol> <p>```java    @Entity    @EntityListeners(AuditingEntityListener.class)    public class User {        @Id        @GeneratedValue(strategy = GenerationType.AUTO)        private Long id;</p> <pre><code>   @CreatedDate\n   private LocalDateTime createdDate;\n\n   @LastModifiedDate\n   private LocalDateTime lastModifiedDate;\n\n   @CreatedBy\n   private String createdBy;\n\n   @LastModifiedBy\n   private String lastModifiedBy;\n\n   // ...existing code...\n</code></pre> <p>}    ```</p>"},{"location":"3_spring_data/#uso-de-specification-para-consultas-dinamicas","title":"Uso de Specification para Consultas Din\u00e1micas","text":"<p>Spring Data JPA proporciona la interfaz <code>Specification</code> para crear consultas din\u00e1micas.</p> <ol> <li> <p>Definir una Especificaci\u00f3n:    ```java    public class UserSpecification {        public static Specification hasRole(String role) {            return (root, query, cb) -&gt; cb.equal(root.get(\"role\"), role);        } <p>public static Specification userNameContains(String userName) {        return (root, query, cb) -&gt; cb.like(root.get(\"userName\"), \"%\" + userName + \"%\");    }    }    ``` <li> <p>Utilizar la Especificaci\u00f3n en un Repositorio:    <code>java    @Repository    public interface UserRepository extends JpaRepository&lt;User, Long&gt;, JpaSpecificationExecutor&lt;User&gt; {    }</code></p> </li> <li> <p>Utilizar la Especificaci\u00f3n en un Servicio:    ```java    @Service    public class UserService {        @Autowired        private UserRepository userRepository;</p> <p>public List findUsersByRoleAndUserName(String role, String userName) {        return userRepository.findAll(Specification.where(UserSpecification.hasRole(role))                .and(UserSpecification.userNameContains(userName)));    }    }    ```"},{"location":"3_spring_data/#explicacion-del-codigo_1","title":"Explicaci\u00f3n del C\u00f3digo","text":"<ul> <li><code>@EnableJpaAuditing</code>: Habilita la auditor\u00eda en Spring Data JPA.</li> <li><code>@CreatedDate</code>, <code>@LastModifiedDate</code>, <code>@CreatedBy</code>, <code>@LastModifiedBy</code>: Anotaciones de auditor\u00eda.</li> <li><code>Specification</code>: Interfaz utilizada para crear consultas din\u00e1micas.</li> </ul>"},{"location":"3_spring_data/#beneficios-de-usar-auditoria-y-specification","title":"Beneficios de Usar Auditor\u00eda y Specification","text":"<ul> <li>Auditor\u00eda: Proporciona soporte para auditor\u00eda de entidades, permitiendo rastrear cambios en los datos.</li> <li>Consultas Din\u00e1micas: Permite crear consultas din\u00e1micas utilizando la interfaz <code>Specification</code>.</li> </ul>"},{"location":"3_spring_data/#actividad-practica_1","title":"Actividad Pr\u00e1ctica","text":"<ol> <li>Configurar la Auditor\u00eda en una Entidad:</li> <li>A\u00f1adir las anotaciones de auditor\u00eda a la entidad <code>User</code>.</li> <li>Habilitar la auditor\u00eda en una clase de configuraci\u00f3n.</li> <li> <p>Probar la auditor\u00eda creando y modificando entidades <code>User</code>.</p> </li> <li> <p>Crear Consultas Din\u00e1micas con Specification:</p> </li> <li>Definir especificaciones en la clase <code>UserSpecification</code>.</li> <li>Utilizar las especificaciones en el servicio <code>UserService</code>.</li> <li>Probar las consultas din\u00e1micas utilizando una herramienta como Postman.</li> </ol>"},{"location":"4_spring_security/","title":"Seguridad con Spring Security y JWT","text":""},{"location":"4_spring_security/#capitulo-4-seguridad-con-spring-security-y-jwt","title":"Cap\u00edtulo 4: Seguridad con Spring Security y JWT","text":""},{"location":"4_spring_security/#introduccion-a-spring-security","title":"Introducci\u00f3n a Spring Security","text":"<p>Spring Security es un framework que proporciona autenticaci\u00f3n y autorizaci\u00f3n en aplicaciones Java. Permite proteger aplicaciones contra amenazas comunes como ataques de fuerza bruta, CSRF y XSS, y gestionar roles y permisos de usuarios.</p>"},{"location":"4_spring_security/#configuracion-de-seguridad","title":"Configuraci\u00f3n de Seguridad","text":"<p>La configuraci\u00f3n de seguridad se realiza en una clase anotada con <code>@Configuration</code>. Esta clase extiende <code>WebSecurityConfigurerAdapter</code> y sobreescribe m\u00e9todos para definir c\u00f3mo se gestionar\u00e1 la seguridad en la aplicaci\u00f3n.</p>"},{"location":"4_spring_security/#actividad-practica","title":"Actividad Pr\u00e1ctica","text":"<ol> <li> <p>Configurar Spring Security:    ```java    @Configuration    @EnableWebSecurity    public class SecurityConfig extends WebSecurityConfigurerAdapter {        private static final Logger logger = LoggerFactory.getLogger(SecurityConfig.class);</p> <p>@Autowired    private JwtEntryPoint jwtEntryPoint;</p> <p>@Autowired    private UserDetailsServiceImpl userDetailsService;</p> <p>@Bean    public JwtAuthenticationFilter jwtAuthenticationFilter() {        return new JwtAuthenticationFilter();    }</p> <p>/*     * Configura el AuthenticationManagerBuilder con el UserDetailsService y el PasswordEncoder.     * @param auth el AuthenticationManagerBuilder     * @throws Exception en caso de error     /    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception {        logger.info(\"Configurando AuthenticationManagerBuilder\");        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());    }</p> <p>/     * Configura la seguridad HTTP, deshabilitando CSRF, permitiendo el acceso p\u00fablico a las rutas de autenticaci\u00f3n,     * y requiriendo autenticaci\u00f3n para otras rutas. Tambi\u00e9n configura el manejo de excepciones y la pol\u00edtica de creaci\u00f3n de sesiones.     * @param http el HttpSecurity     * @throws Exception en caso de error     */    @Override    protected void configure(HttpSecurity http) throws Exception {        logger.info(\"Configurando HttpSecurity\");        http.csrf().disable()            .authorizeRequests()            .antMatchers(\"/auth/\").permitAll()            .anyRequest().authenticated()            .and()            .exceptionHandling().authenticationEntryPoint(jwtEntryPoint)            .and()            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);</p> <pre><code>   http.addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);\n</code></pre> <p>}</p> <p>/*     * Define el PasswordEncoder que se utilizar\u00e1 para codificar las contrase\u00f1as.     * @return el PasswordEncoder     /    @Bean    public PasswordEncoder passwordEncoder() {        return new BCryptPasswordEncoder();    }</p> <p>/*     * Define el AuthenticationManager que se utilizar\u00e1 para la autenticaci\u00f3n.     * @return el AuthenticationManager     * @throws Exception en caso de error     /    @Bean    @Override    public AuthenticationManager authenticationManagerBean() throws Exception {        return super.authenticationManagerBean();    }    }    ```</p> </li> </ol> <p>Esta clase <code>SecurityConfig</code> extiende <code>WebSecurityConfigurerAdapter</code> y se encarga de la configuraci\u00f3n de seguridad de la aplicaci\u00f3n. Aqu\u00ed se configuran varios aspectos importantes y se utiliza un Logger para registrar eventos importantes:</p> <ul> <li><code>configure(AuthenticationManagerBuilder auth)</code>: Configura el <code>AuthenticationManagerBuilder</code> con el <code>UserDetailsService</code> y el <code>PasswordEncoder</code>. Esto asegura que el <code>AuthenticationManagerBuilder</code> pueda autenticar usuarios utilizando el <code>UserDetailsService</code> y el <code>PasswordEncoder</code> configurados.</li> <li><code>configure(HttpSecurity http)</code>: Configura la seguridad HTTP, deshabilitando CSRF, permitiendo el acceso p\u00fablico a las rutas de autenticaci\u00f3n, y requiriendo autenticaci\u00f3n para otras rutas. Tambi\u00e9n configura el manejo de excepciones y la pol\u00edtica de creaci\u00f3n de sesiones. Esto garantiza que las rutas de autenticaci\u00f3n sean accesibles p\u00fablicamente, mientras que otras rutas requieren autenticaci\u00f3n.</li> <li><code>passwordEncoder()</code>: Define el <code>PasswordEncoder</code> que se utilizar\u00e1 para codificar las contrase\u00f1as. Esto asegura que las contrase\u00f1as se codifiquen de manera segura antes de almacenarse.</li> <li><code>authenticationManagerBean()</code>: Define el <code>AuthenticationManager</code> que se utilizar\u00e1 para la autenticaci\u00f3n. Esto garantiza que el <code>AuthenticationManager</code> est\u00e9 disponible como un bean en el contexto de la aplicaci\u00f3n.</li> </ul>"},{"location":"4_spring_security/#criptografia-y-cifrado-de-contrasenas","title":"Criptograf\u00eda y Cifrado de Contrase\u00f1as","text":""},{"location":"4_spring_security/#introduccion-a-la-criptografia","title":"Introducci\u00f3n a la Criptograf\u00eda","text":"<p>La criptograf\u00eda es la pr\u00e1ctica y el estudio de t\u00e9cnicas para asegurar la comunicaci\u00f3n y proteger la informaci\u00f3n. En el contexto de aplicaciones web, se utiliza para proteger datos sensibles como contrase\u00f1as y tokens de autenticaci\u00f3n.</p>"},{"location":"4_spring_security/#implementacion-de-cifrado-de-contrasenas-y-datos","title":"Implementaci\u00f3n de Cifrado de Contrase\u00f1as y Datos","text":"<p>La implementaci\u00f3n de cifrado de contrase\u00f1as y datos se realiza utilizando Spring Security y BCrypt. BCrypt es un algoritmo de hashing que incluye un factor de trabajo, lo que lo hace m\u00e1s seguro contra ataques de fuerza bruta.</p>"},{"location":"4_spring_security/#actividad-practica_1","title":"Actividad Pr\u00e1ctica","text":"<ol> <li>Implementar cifrado de contrase\u00f1as:    <code>java    @Bean    public PasswordEncoder passwordEncoder() {        return new BCryptPasswordEncoder();    }</code></li> </ol>"},{"location":"4_spring_security/#gestion-de-jwt","title":"Gesti\u00f3n de JWT","text":"<p>Para gestionar los JWT, necesitamos tres clases en el paquete <code>security.jwt</code>:</p> <ol> <li>JwtTokenProvider: Provee m\u00e9todos para generar y validar tokens JWT.</li> <li>JwtTokenFilter: Filtro que intercepta las solicitudes HTTP para validar el token JWT.</li> <li>JwtAuthenticationEntryPoint: Maneja los errores de autenticaci\u00f3n.</li> </ol>"},{"location":"4_spring_security/#ejemplo-de-jwttokenprovider","title":"Ejemplo de <code>JwtTokenProvider</code>","text":"<pre><code>package com.example.security.jwt;\n\nimport io.jsonwebtoken.Claims;\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.SignatureAlgorithm;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Date;\n\n/**\n * Proveedor de JWT que genera y valida tokens JWT.\n */\n@Component\npublic class JwtTokenProvider {\n\n    @Value(\"${jwt.secret}\")\n    private String secretKey;\n\n    @Value(\"${jwt.expiration}\")\n    private long validityInMilliseconds;\n\n    /**\n     * Genera un token JWT basado en la autenticaci\u00f3n del usuario.\n     *\n     * @param authentication la autenticaci\u00f3n del usuario\n     * @return el token JWT\n     */\n    public String createToken(Authentication authentication) {\n        UserDetails userDetails = (UserDetails) authentication.getPrincipal();\n        Claims claims = Jwts.claims().setSubject(userDetails.getUsername());\n        Date now = new Date();\n        Date validity = new Date(now.getTime() + validityInMilliseconds);\n\n        return Jwts.builder()\n                .setClaims(claims)\n                .setIssuedAt(now)\n                .setExpiration(validity)\n                .signWith(SignatureAlgorithm.HS256, secretKey)\n                .compact();\n    }\n\n    /**\n     * Valida el token JWT.\n     *\n     * @param token el token JWT\n     * @return true si el token es v\u00e1lido, false en caso contrario\n     */\n    public boolean validateToken(String token) {\n        try {\n            Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token);\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    /**\n     * Extrae el nombre de usuario del token JWT.\n     *\n     * @param token el token JWT\n     * @return el nombre de usuario\n     */\n    public String getUsername(String token) {\n        return Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token).getBody().getSubject();\n    }\n}\n</code></pre> <p>Esta clase <code>JwtTokenProvider</code> se encarga de generar y validar tokens JWT. Utiliza la biblioteca <code>io.jsonwebtoken</code> para crear y analizar los tokens. Los m\u00e9todos principales son <code>createToken</code>, que genera un token basado en la autenticaci\u00f3n del usuario, y <code>validateToken</code>, que valida el token.</p>"},{"location":"4_spring_security/#ejemplo-de-jwttokenfilter","title":"Ejemplo de <code>JwtTokenFilter</code>","text":"<pre><code>package com.example.security.jwt;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.web.authentication.WebAuthenticationDetailsSource;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.filter.OncePerRequestFilter;\n\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * Filtro que intercepta las solicitudes HTTP para validar el token JWT.\n */\n@Component\npublic class JwtTokenFilter extends OncePerRequestFilter {\n\n    @Autowired\n    private JwtTokenProvider jwtTokenProvider;\n\n    @Autowired\n    private UserDetailsService userDetailsService;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n            throws ServletException, IOException {\n        String token = resolveToken(request);\n        if (token != null &amp;&amp; jwtTokenProvider.validateToken(token)) {\n            String username = jwtTokenProvider.getUsername(token);\n            UserDetails userDetails = userDetailsService.loadUserByUsername(username);\n            if (userDetails != null) {\n                JwtAuthenticationToken authentication = new JwtAuthenticationToken(userDetails, null, userDetails.getAuthorities());\n                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));\n                SecurityContextHolder.getContext().setAuthentication(authentication);\n            }\n        }\n        filterChain.doFilter(request, response);\n    }\n\n    private String resolveToken(HttpServletRequest request) {\n        String bearerToken = request.getHeader(\"Authorization\");\n        if (bearerToken != null &amp;&amp; bearerToken.startsWith(\"Bearer \")) {\n            return bearerToken.substring(7);\n        }\n        return null;\n    }\n}\n</code></pre> <p>Esta clase <code>JwtTokenFilter</code> extiende <code>OncePerRequestFilter</code> y se encarga de interceptar las solicitudes HTTP para validar el token JWT. Si el token es v\u00e1lido, se establece la autenticaci\u00f3n en el contexto de seguridad de Spring.</p>"},{"location":"4_spring_security/#ejemplo-de-jwtauthenticationentrypoint","title":"Ejemplo de <code>JwtAuthenticationEntryPoint</code>","text":"<pre><code>package com.example.security.jwt;\n\nimport org.springframework.security.core.AuthenticationException;\nimport org.springframework.security.web.AuthenticationEntryPoint;\nimport org.springframework.stereotype.Component;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * Punto de entrada de autenticaci\u00f3n que maneja los errores de autenticaci\u00f3n.\n */\n@Component\npublic class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {\n\n    @Override\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)\n            throws IOException {\n        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Unauthorized\");\n    }\n}\n</code></pre> <p>Esta clase <code>JwtAuthenticationEntryPoint</code> implementa <code>AuthenticationEntryPoint</code> y se encarga de manejar los errores de autenticaci\u00f3n. Si una solicitud no autenticada intenta acceder a un recurso protegido, se devuelve un error 401 (Unauthorized).</p>"},{"location":"4_spring_security/#implementacion-de-jwt-en-spring-security","title":"Implementaci\u00f3n de JWT en Spring Security","text":"<p>La implementaci\u00f3n de JWT en Spring Security incluye la creaci\u00f3n de un proveedor de JWT, un filtro de autenticaci\u00f3n y un punto de entrada de autenticaci\u00f3n. Estos componentes se integran en la configuraci\u00f3n de seguridad de Spring Security para proporcionar autenticaci\u00f3n basada en tokens JWT.</p>"},{"location":"4_spring_security/#actividad-practica_2","title":"Actividad Pr\u00e1ctica","text":"<ol> <li> <p>Crear el proveedor de JWT <code>JwtProvider</code>:    ```java    @Component    public class JwtProvider {        private String secret = \"secret\";</p> <p>public String generateToken(Authentication authentication) {        UserDetails userDetails = (UserDetails) authentication.getPrincipal();        return Jwts.builder()                .setSubject(userDetails.getUsername())                .setIssuedAt(new Date())                .setExpiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60 * 10)) // 10 horas de expiraci\u00f3n                .signWith(SignatureAlgorithm.HS256, secret)                .compact();    }</p> <p>public String extractUsername(String token) {        return extractClaim(token, Claims::getSubject);    }</p> <p>public Date extractExpiration(String token) {        return extractClaim(token, Claims::getExpiration);    }</p> <p>public  T extractClaim(String token, Function claimsResolver) {        final Claims claims = extractAllClaims(token);        return claimsResolver.apply(claims);    } <p>private Claims extractAllClaims(String token) {        return Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody();    }</p> <p>private Boolean isTokenExpired(String token) {        return extractExpiration(token).before(new Date());    }</p> <p>public boolean validateToken(String token) {        try {            Jwts.parser().setSigningKey(secret).parseClaimsJws(token);            return true;        } catch (JwtException | IllegalArgumentException e) {            System.err.println(\"Token JWT inv\u00e1lido\");        }        return false;    }</p> <p>public Boolean validateToken(String token, UserDetails userDetails) {        final String username = extractUsername(token);        return (username.equals(userDetails.getUsername()) &amp;&amp; !isTokenExpired(token));    }    }    ```</p>"},{"location":"4_spring_security/#proteger-endpoints-con-roles","title":"Proteger Endpoints con Roles","text":"<p>Para proteger endpoints con roles, se pueden utilizar las anotaciones <code>@PreAuthorize</code> o <code>@Secured</code>. A continuaci\u00f3n se muestra un ejemplo de c\u00f3mo proteger un endpoint utilizando <code>@PreAuthorize</code>:</p> <ol> <li>Habilitar la Seguridad basada en Anotaciones:</li> <li> <p>A\u00f1adir la anotaci\u00f3n <code>@EnableGlobalMethodSecurity</code> en la clase de configuraci\u00f3n de seguridad:      <code>java      @Configuration      @EnableWebSecurity      @EnableGlobalMethodSecurity(prePostEnabled = true)      public class SecurityConfig extends WebSecurityConfigurerAdapter {          // ...existing code...      }</code></p> </li> <li> <p>Proteger un Endpoint con <code>@PreAuthorize</code>:</p> </li> <li>Utilizar la anotaci\u00f3n <code>@PreAuthorize</code> en el controlador para proteger un endpoint:      ```java      @RestController      @RequestMapping(\"/api/admin\")      public class AdminController {<pre><code> @PreAuthorize(\"hasRole('ADMIN')\")\n @GetMapping(\"/dashboard\")\n public String getAdminDashboard() {\n     return \"Admin Dashboard\";\n }\n</code></pre> <p>}  ```</p> </li> </ol> <p>En este ejemplo, el endpoint <code>/api/admin/dashboard</code> solo ser\u00e1 accesible para usuarios con el rol <code>ADMIN</code>.</p>"},{"location":"4_spring_security/#explicacion-del-codigo","title":"Explicaci\u00f3n del C\u00f3digo","text":"<ul> <li><code>@EnableGlobalMethodSecurity(prePostEnabled = true)</code>: Habilita la seguridad basada en anotaciones en la aplicaci\u00f3n.</li> <li><code>@PreAuthorize(\"hasRole('ADMIN')\")</code>: Protege el endpoint para que solo sea accesible para usuarios con el rol <code>ADMIN</code>.</li> </ul>"},{"location":"4_spring_security/#actividad-practica_3","title":"Actividad Pr\u00e1ctica","text":"<ol> <li>Proteger un Endpoint con Roles:</li> <li>A\u00f1adir la anotaci\u00f3n <code>@EnableGlobalMethodSecurity(prePostEnabled = true)</code> en la clase de configuraci\u00f3n de seguridad.</li> <li>Utilizar la anotaci\u00f3n <code>@PreAuthorize</code> en un controlador para proteger un endpoint con un rol espec\u00edfico.</li> <li>Probar el acceso al endpoint con diferentes usuarios para verificar que solo los usuarios con el rol adecuado pueden acceder.</li> </ol>"},{"location":"4_spring_security/#validaciones-en-el-controlador-usercontroller","title":"Validaciones en el Controlador <code>UserController</code>","text":"<p>Para agregar validaciones en el controlador <code>UserController</code>, se pueden utilizar anotaciones de validaci\u00f3n en los m\u00e9todos del controlador. A continuaci\u00f3n se muestra un ejemplo de c\u00f3mo agregar validaciones en el controlador <code>UserController</code>:</p> <pre><code>package com.example.controller;\n\nimport com.example.model.User;\nimport com.example.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.validation.annotation.Validated;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.validation.Valid;\nimport javax.validation.constraints.NotBlank;\nimport javax.validation.constraints.Size;\nimport java.util.List;\n\n@RestController\n@RequestMapping(\"/users\")\n@Validated\npublic class UserController {\n\n    @Autowired\n    private UserService userService;\n\n    @GetMapping\n    public List&lt;User&gt; getAllUsers() {\n        return userService.getAllUsers();\n    }\n\n    @GetMapping(\"/{id}\")\n    public ResponseEntity&lt;User&gt; getUserById(@PathVariable Long id) {\n        User user = userService.getUserById(id);\n        if (user != null) {\n            return ResponseEntity.ok(user);\n        } else {\n            return ResponseEntity.notFound().build();\n        }\n    }\n\n    @PostMapping\n    public ResponseEntity&lt;User&gt; createUser(@Valid @RequestBody User user) {\n        User createdUser = userService.createUser(user);\n        return ResponseEntity.ok(createdUser);\n    }\n\n    @PutMapping(\"/{id}\")\n    public ResponseEntity&lt;User&gt; updateUser(@PathVariable Long id, @Valid @RequestBody User user) {\n        User updatedUser = userService.updateUser(id, user);\n        if (updatedUser != null) {\n            return ResponseEntity.ok(updatedUser);\n        } else {\n            return ResponseEntity.notFound().build();\n        }\n    }\n\n    @DeleteMapping(\"/{id}\")\n    public ResponseEntity&lt;Void&gt; deleteUser(@PathVariable Long id) {\n        boolean deleted = userService.deleteUser(id);\n        if (deleted) {\n            return ResponseEntity.noContent().build();\n        } else {\n            return ResponseEntity.notFound().build();\n        }\n    }\n}\n</code></pre> <p>En este ejemplo, se utilizan las anotaciones <code>@Valid</code> y <code>@Validated</code> para habilitar la validaci\u00f3n de los datos de entrada en los m\u00e9todos del controlador. La anotaci\u00f3n <code>@Valid</code> se utiliza en los par\u00e1metros de los m\u00e9todos para indicar que los datos de entrada deben ser validados. La anotaci\u00f3n <code>@Validated</code> se utiliza en la clase del controlador para habilitar la validaci\u00f3n a nivel de clase.</p> <p>Adem\u00e1s, se pueden agregar anotaciones de validaci\u00f3n en el modelo <code>User</code> para definir las reglas de validaci\u00f3n. A continuaci\u00f3n se muestra un ejemplo de c\u00f3mo agregar anotaciones de validaci\u00f3n en el modelo <code>User</code>:</p> <pre><code>package com.example.model;\n\nimport javax.validation.constraints.Email;\nimport javax.validation.constraints.NotBlank;\nimport javax.validation.constraints.Size;\n\npublic class User {\n\n    private Long id;\n\n    @NotBlank(message = \"El nombre es obligatorio\")\n    @Size(max = 50, message = \"El nombre no puede tener m\u00e1s de 50 caracteres\")\n    private String name;\n\n    @NotBlank(message = \"El correo electr\u00f3nico es obligatorio\")\n    @Email(message = \"El correo electr\u00f3nico debe ser v\u00e1lido\")\n    private String email;\n\n    // Getters y setters\n}\n</code></pre> <p>En este ejemplo, se utilizan las anotaciones <code>@NotBlank</code>, <code>@Size</code> y <code>@Email</code> para definir las reglas de validaci\u00f3n en los campos del modelo <code>User</code>. Estas anotaciones aseguran que los datos de entrada cumplan con las reglas de validaci\u00f3n antes de ser procesados por el controlador.</p>"},{"location":"5_swagger/","title":"Documentaci\u00f3n con Swagger","text":""},{"location":"5_swagger/#capitulo-5-documentacion-con-swagger","title":"Cap\u00edtulo 5: Documentaci\u00f3n con Swagger","text":""},{"location":"5_swagger/#introduccion-a-swagger","title":"Introducci\u00f3n a Swagger","text":"<p>Swagger es una herramienta para documentar y probar APIs RESTful. Proporciona una interfaz de usuario interactiva que permite a los desarrolladores explorar y probar los endpoints de la API de manera sencilla. Swagger facilita la creaci\u00f3n de documentaci\u00f3n detallada y actualizada de las APIs, lo que mejora la comunicaci\u00f3n entre los equipos de desarrollo y otros stakeholders.</p>"},{"location":"5_swagger/#configuracion-de-swagger-en-spring-boot","title":"Configuraci\u00f3n de Swagger en Spring Boot","text":"<p>La configuraci\u00f3n de Swagger se realiza en una clase anotada con <code>@Configuration</code>. Esta clase define un bean <code>Docket</code> que configura Swagger para escanear los controladores y generar la documentaci\u00f3n de la API.</p>"},{"location":"5_swagger/#actividad-practica","title":"Actividad Pr\u00e1ctica","text":"<ol> <li>Configurar Swagger:</li> <li>Crear una clase de configuraci\u00f3n para Swagger en el paquete <code>config</code>.</li> </ol> <p>```java    @Configuration    @EnableSwagger2    public class SwaggerConfig {        private static final Logger logger = LoggerFactory.getLogger(SwaggerConfig.class);</p> <pre><code>   @Bean\n   public Docket api() {\n       logger.info(\"Configurando Swagger Docket\");\n       return new Docket(DocumentationType.SWAGGER_2)\n               .select()\n               .apis(RequestHandlerSelectors.basePackage(\"com.demospring.security.controller\"))\n               .paths(PathSelectors.any())\n               .build()\n               .apiInfo(apiInfo());\n   }\n\n   private ApiInfo apiInfo() {\n       logger.debug(\"Configurando ApiInfo\");\n       return new ApiInfoBuilder()\n               .title(\"API de Seguridad\")\n               .description(\"Documentaci\u00f3n de la API de Seguridad con Spring Boot y Swagger\")\n               .version(\"1.0.0\")\n               .build();\n   }\n</code></pre> <p>}    ```</p> <p>En esta configuraci\u00f3n:    - La anotaci\u00f3n <code>@EnableSwagger2</code> habilita Swagger en la aplicaci\u00f3n.    - El m\u00e9todo <code>api()</code> define un bean <code>Docket</code> que configura Swagger para escanear los controladores en el paquete <code>com.demospring.security.controller</code>.    - El m\u00e9todo <code>select()</code> permite personalizar qu\u00e9 controladores y rutas se incluir\u00e1n en la documentaci\u00f3n de Swagger.    - <code>apis(RequestHandlerSelectors.basePackage(\"com.demospring.security.controller\"))</code> especifica que solo se escanear\u00e1n los controladores en el paquete <code>com.demospring.security.controller</code>.    - <code>paths(PathSelectors.any())</code> indica que se incluir\u00e1n todas las rutas en la documentaci\u00f3n.    - <code>apiInfo()</code> proporciona informaci\u00f3n adicional sobre la API, como el t\u00edtulo, la descripci\u00f3n y la versi\u00f3n.    - Se utiliza un Logger para registrar eventos importantes durante la configuraci\u00f3n de Swagger.</p> <p>Una vez configurado, Swagger generar\u00e1 autom\u00e1ticamente la documentaci\u00f3n de la API y proporcionar\u00e1 una interfaz de usuario interactiva en la ruta <code>/swagger-ui.html</code>.</p>"},{"location":"5_swagger/#personalizacion-de-swagger-para-mostrar-ejemplos-especificos","title":"Personalizaci\u00f3n de Swagger para Mostrar Ejemplos Espec\u00edficos","text":"<p>Para personalizar Swagger y mostrar ejemplos espec\u00edficos en los endpoints, se pueden utilizar anotaciones como <code>@ApiOperation</code> y <code>@ApiResponses</code> en los controladores. Aqu\u00ed hay un ejemplo:</p> <pre><code>@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    private static final Logger logger = LoggerFactory.getLogger(UserController.class);\n\n    @ApiOperation(value = \"Obtener todos los usuarios\", response = List.class)\n    @ApiResponses(value = {\n        @ApiResponse(code = 200, message = \"Usuarios obtenidos con \u00e9xito\"),\n        @ApiResponse(code = 401, message = \"No autorizado\"),\n        @ApiResponse(code = 403, message = \"Prohibido\"),\n        @ApiResponse(code = 404, message = \"No encontrado\")\n    })\n    @GetMapping\n    public ResponseEntity&lt;List&lt;User&gt;&gt; getAllUsers() {\n        logger.info(\"getAllUsers endpoint llamado\");\n        // ...existing code...\n    }\n\n    @ApiOperation(value = \"Crear un nuevo usuario\")\n    @ApiResponses(value = {\n        @ApiResponse(code = 201, message = \"Usuario creado con \u00e9xito\"),\n        @ApiResponse(code = 400, message = \"Solicitud incorrecta\")\n    })\n    @PostMapping\n    public ResponseEntity&lt;User&gt; createUser(@RequestBody User user) {\n        logger.info(\"createUser endpoint llamado con datos: {}\", user);\n        // ...existing code...\n    }\n}\n</code></pre> <p>En este ejemplo: - <code>@ApiOperation</code> describe la operaci\u00f3n del endpoint. - <code>@ApiResponses</code> define las posibles respuestas del endpoint, incluyendo c\u00f3digos de estado y mensajes. - <code>Logger</code>: Utilizado para registrar eventos importantes y errores en la aplicaci\u00f3n.</p>"},{"location":"5_swagger/#generar-un-cliente-api-desde-la-documentacion-swagger","title":"Generar un Cliente API desde la Documentaci\u00f3n Swagger","text":"<p>Swagger tambi\u00e9n permite generar clientes API autom\u00e1ticamente desde la documentaci\u00f3n. Aqu\u00ed hay un ejemplo de c\u00f3mo hacerlo:</p> <ol> <li>Acceder a la Interfaz de Usuario de Swagger:</li> <li>Inicia la aplicaci\u00f3n Spring Boot.</li> <li> <p>Abre un navegador web y navega a <code>http://localhost:8080/swagger-ui.html</code>.</p> </li> <li> <p>Generar el Cliente API:</p> </li> <li>En la interfaz de usuario de Swagger, haz clic en el bot\u00f3n \"Generate Client\".</li> <li>Selecciona el lenguaje de programaci\u00f3n deseado (por ejemplo, Java, Python, etc.).</li> <li>Descarga el c\u00f3digo del cliente API generado.</li> </ol> <p>Este cliente API puede ser utilizado para interactuar con la API documentada sin necesidad de escribir c\u00f3digo adicional para las solicitudes HTTP.</p>"},{"location":"5_swagger/#explicacion-del-codigo","title":"Explicaci\u00f3n del C\u00f3digo","text":"<ul> <li><code>@Configuration</code>: Indica que esta clase es una clase de configuraci\u00f3n de Spring.</li> <li><code>@EnableSwagger2</code>: Habilita Swagger en la aplicaci\u00f3n.</li> <li><code>Docket api()</code>: Define un bean <code>Docket</code> que configura Swagger para escanear los controladores y generar la documentaci\u00f3n de la API.</li> <li><code>select()</code>: Permite personalizar qu\u00e9 controladores y rutas se incluir\u00e1n en la documentaci\u00f3n de Swagger.</li> <li><code>apis(RequestHandlerSelectors.basePackage(\"com.demospring.security.controller\"))</code>: Especifica que solo se escanear\u00e1n los controladores en el paquete <code>com.demospring.security.controller</code>.</li> <li><code>paths(PathSelectors.any())</code>: Indica que se incluir\u00e1n todas las rutas en la documentaci\u00f3n.</li> </ul>"},{"location":"5_swagger/#beneficios-de-usar-swagger","title":"Beneficios de Usar Swagger","text":"<ul> <li>Documentaci\u00f3n Autom\u00e1tica: Swagger genera autom\u00e1ticamente la documentaci\u00f3n de la API basada en los controladores y m\u00e9todos definidos en el c\u00f3digo.</li> <li>Interfaz de Usuario Interactiva: Proporciona una interfaz de usuario interactiva que permite a los desarrolladores explorar y probar los endpoints de la API.</li> <li>Mejora la Comunicaci\u00f3n: Facilita la comunicaci\u00f3n entre los equipos de desarrollo y otros stakeholders al proporcionar una documentaci\u00f3n clara y actualizada de la API.</li> <li>Facilita el Desarrollo: Permite a los desarrolladores probar r\u00e1pidamente los endpoints de la API sin necesidad de escribir c\u00f3digo adicional para las pruebas.</li> </ul>"},{"location":"5_swagger/#actividad-practica_1","title":"Actividad Pr\u00e1ctica","text":"<ol> <li>Acceder a la Interfaz de Usuario de Swagger:</li> <li>Una vez configurado Swagger, inicia la aplicaci\u00f3n Spring Boot.</li> <li>Abre un navegador web y navega a <code>http://localhost:8080/swagger-ui.html</code>.</li> <li>Explora la interfaz de usuario de Swagger para ver y probar los endpoints de la API.</li> </ol>"},{"location":"6_servcios_red/","title":"Implementaci\u00f3n de Servicios en Red","text":""},{"location":"6_servcios_red/#capitulo-6-implementacion-de-servicios-en-red","title":"Cap\u00edtulo 6: Implementaci\u00f3n de Servicios en Red","text":""},{"location":"6_servcios_red/#introduccion-a-los-servicios-en-red","title":"Introducci\u00f3n a los Servicios en Red","text":"<p>Los servicios en red permiten la comunicaci\u00f3n entre aplicaciones a trav\u00e9s de la red. Estos servicios son esenciales para la arquitectura de microservicios y aplicaciones distribuidas, donde diferentes componentes de la aplicaci\u00f3n necesitan comunicarse entre s\u00ed.</p>"},{"location":"6_servcios_red/#implementacion-de-un-servicio-de-envio-de-correos-electronicos","title":"Implementaci\u00f3n de un Servicio de Env\u00edo de Correos Electr\u00f3nicos","text":"<p>La implementaci\u00f3n de un servicio de env\u00edo de correos electr\u00f3nicos se realiza utilizando Spring Boot y JavaMailSender. Este servicio permite enviar correos electr\u00f3nicos desde la aplicaci\u00f3n, lo cual es \u00fatil para notificaciones, confirmaciones de registro, restablecimiento de contrase\u00f1as, entre otros.</p>"},{"location":"6_servcios_red/#actividad-practica","title":"Actividad Pr\u00e1ctica","text":"<ol> <li>Configurar las Dependencias de JavaMailSender:</li> <li> <p>A\u00f1adir las dependencias necesarias en el archivo <code>pom.xml</code>:      <code>xml      &lt;dependency&gt;          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;          &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;      &lt;/dependency&gt;</code></p> </li> <li> <p>Configurar las Propiedades del Correo Electr\u00f3nico:</p> </li> <li> <p>Configurar las propiedades del correo electr\u00f3nico en el archivo <code>application.properties</code>:      <code>properties      spring.mail.host=smtp.mailtrap.io      spring.mail.port=2525      spring.mail.username=your-mailtrap-username      spring.mail.password=your-mailtrap-password      spring.mail.properties.mail.smtp.auth=true      spring.mail.properties.mail.smtp.starttls.enable=true</code></p> </li> <li> <p>Crear el Servicio de Env\u00edo de Correos Electr\u00f3nicos:</p> </li> <li>Crear una clase <code>EmailService</code> en el paquete <code>service</code>:      ```java      @Service      public class EmailService {          private static final Logger logger = LoggerFactory.getLogger(EmailService.class);<pre><code> @Autowired\n private JavaMailSender mailSender;\n\n public void sendEmail(String to, String subject, String text) {\n     try {\n         logger.info(\"Enviando correo a: {}\", to);\n         SimpleMailMessage message = new SimpleMailMessage();\n         message.setTo(to);\n         message.setSubject(subject);\n         message.setText(text);\n         mailSender.send(message);\n         logger.info(\"Correo enviado a: {}\", to);\n     } catch (MailException e) {\n         logger.error(\"Error al enviar el correo: {}\", e.getMessage());\n     }\n }\n\n public void sendEmailWithAttachment(String to, String subject, String text, String pathToAttachment) {\n     try {\n         logger.info(\"Enviando correo con adjunto a: {}\", to);\n         MimeMessage message = mailSender.createMimeMessage();\n         MimeMessageHelper helper = new MimeMessageHelper(message, true);\n\n         helper.setTo(to);\n         helper.setSubject(subject);\n         helper.setText(text);\n\n         FileSystemResource file = new FileSystemResource(new File(pathToAttachment));\n         helper.addAttachment(\"Adjunto\", file);\n\n         mailSender.send(message);\n         logger.info(\"Correo con adjunto enviado a: {}\", to);\n     } catch (MessagingException | MailException e) {\n         logger.error(\"Error al enviar el correo con adjunto: {}\", e.getMessage());\n     }\n }\n</code></pre> <p>}  ```</p> </li> </ol>"},{"location":"6_servcios_red/#explicacion-del-codigo","title":"Explicaci\u00f3n del C\u00f3digo","text":"<ul> <li><code>@Service</code>: Indica que esta clase es un servicio de Spring.</li> <li><code>JavaMailSender</code>: Es una interfaz proporcionada por Spring Boot para enviar correos electr\u00f3nicos.</li> <li><code>sendEmail(String to, String subject, String text)</code>: M\u00e9todo que env\u00eda un correo electr\u00f3nico con el destinatario, asunto y texto especificados. Maneja errores utilizando un bloque <code>try-catch</code>.</li> <li><code>sendEmailWithAttachment(String to, String subject, String text, String pathToAttachment)</code>: M\u00e9todo que env\u00eda un correo electr\u00f3nico con un archivo adjunto. Utiliza <code>MimeMessageHelper</code> para configurar el mensaje con el archivo adjunto.</li> </ul>"},{"location":"6_servcios_red/#uso-de-mailtrap-para-pruebas-de-correo-electronico","title":"Uso de Mailtrap para Pruebas de Correo Electr\u00f3nico","text":"<p>Mailtrap es una herramienta que permite probar el env\u00edo de correos electr\u00f3nicos sin necesidad de configurar un servidor SMTP real. Aqu\u00ed se explica c\u00f3mo configurarlo:</p> <ol> <li>Crear una Cuenta en Mailtrap:</li> <li> <p>Reg\u00edstrate en Mailtrap y crea un inbox.</p> </li> <li> <p>Obtener las Credenciales SMTP:</p> </li> <li> <p>En el dashboard de Mailtrap, selecciona el inbox y copia las credenciales SMTP (host, puerto, nombre de usuario y contrase\u00f1a).</p> </li> <li> <p>Configurar las Propiedades del Correo Electr\u00f3nico:</p> </li> <li>Configura las propiedades del correo electr\u00f3nico en el archivo <code>application.properties</code> utilizando las credenciales de Mailtrap:      <code>properties      spring.mail.host=smtp.mailtrap.io      spring.mail.port=2525      spring.mail.username=your-mailtrap-username      spring.mail.password=your-mailtrap-password      spring.mail.properties.mail.smtp.auth=true      spring.mail.properties.mail.smtp.starttls.enable=true</code></li> </ol>"},{"location":"6_servcios_red/#beneficios-de-usar-javamailsender","title":"Beneficios de Usar JavaMailSender","text":"<ul> <li>Simplicidad: JavaMailSender simplifica el env\u00edo de correos electr\u00f3nicos al proporcionar una API f\u00e1cil de usar.</li> <li>Configuraci\u00f3n Flexible: Permite configurar diversas propiedades del correo electr\u00f3nico, como el servidor SMTP, puerto, autenticaci\u00f3n, entre otros.</li> <li>Integraci\u00f3n con Spring Boot: Se integra f\u00e1cilmente con aplicaciones Spring Boot, lo que facilita su configuraci\u00f3n y uso.</li> </ul>"},{"location":"6_servcios_red/#actividad-practica_1","title":"Actividad Pr\u00e1ctica","text":"<ol> <li>Enviar un Correo Electr\u00f3nico de Prueba:</li> <li> <p>Crear un controlador REST para probar el env\u00edo de correos electr\u00f3nicos:      ```java      @RestController      @RequestMapping(\"/api/email\")      public class EmailController {          @Autowired          private EmailService emailService;</p> <pre><code> @PostMapping(\"/send\")\n public ResponseEntity&lt;String&gt; sendEmail(@RequestParam String to, @RequestParam String subject, @RequestParam String text) {\n     emailService.sendEmail(to, subject, text);\n     return ResponseEntity.ok(\"Email sent successfully\");\n }\n\n @PostMapping(\"/sendWithAttachment\")\n public ResponseEntity&lt;String&gt; sendEmailWithAttachment(@RequestParam String to, @RequestParam String subject, @RequestParam String text, @RequestParam String pathToAttachment) {\n     emailService.sendEmailWithAttachment(to, subject, text, pathToAttachment);\n     return ResponseEntity.ok(\"Email with attachment sent successfully\");\n }\n</code></pre> <p>}  ```</p> </li> <li> <p>Probar el Env\u00edo de Correos Electr\u00f3nicos:</p> </li> <li>Iniciar la aplicaci\u00f3n Spring Boot.</li> <li>Utilizar una herramienta como Postman para enviar una solicitud POST a <code>http://localhost:8080/api/email/send</code> con los par\u00e1metros <code>to</code>, <code>subject</code> y <code>text</code>.</li> <li> <p>Verificar que el correo electr\u00f3nico se env\u00eda correctamente.</p> </li> <li> <p>Probar el Env\u00edo de Correos Electr\u00f3nicos con Archivos Adjuntos:</p> </li> <li>Utilizar una herramienta como Postman para enviar una solicitud POST a <code>http://localhost:8080/api/email/sendWithAttachment</code> con los par\u00e1metros <code>to</code>, <code>subject</code>, <code>text</code> y <code>pathToAttachment</code>.</li> <li>Verificar que el correo electr\u00f3nico con el archivo adjunto se env\u00eda correctamente.</li> </ol>"},{"location":"6_servcios_red/#manejo-de-errores-comunes","title":"Manejo de Errores Comunes","text":"<p>Es importante manejar errores comunes al enviar correos electr\u00f3nicos, como problemas de conexi\u00f3n o autenticaci\u00f3n. Aqu\u00ed hay un ejemplo de c\u00f3mo manejar estos errores en el servicio de env\u00edo de correos:</p> <pre><code>@Service\npublic class EmailService {\n    private static final Logger logger = LoggerFactory.getLogger(EmailService.class);\n\n    @Autowired\n    private JavaMailSender mailSender;\n\n    public void sendEmail(String to, String subject, String text) {\n        try {\n            logger.info(\"Enviando correo a: {}\", to);\n            SimpleMailMessage message = new SimpleMailMessage();\n            message.setTo(to);\n            message.setSubject(subject);\n            message.setText(text);\n            mailSender.send(message);\n            logger.info(\"Correo enviado a: {}\", to);\n        } catch (MailAuthenticationException e) {\n            logger.error(\"Error de autenticaci\u00f3n: {}\", e.getMessage());\n        } catch (MailSendException e) {\n            logger.error(\"Error al enviar el correo: {}\", e.getMessage());\n        } catch (MailException e) {\n            logger.error(\"Error general de correo: {}\", e.getMessage());\n        }\n    }\n\n    public void sendEmailWithAttachment(String to, String subject, String text, String pathToAttachment) {\n        try {\n            logger.info(\"Enviando correo con adjunto a: {}\", to);\n            MimeMessage message = mailSender.createMimeMessage();\n            MimeMessageHelper helper = new MimeMessageHelper(message, true);\n\n            helper.setTo(to);\n            helper.setSubject(subject);\n            helper.setText(text);\n\n            FileSystemResource file = new FileSystemResource(new File(pathToAttachment));\n            helper.addAttachment(\"Adjunto\", file);\n\n            mailSender.send(message);\n            logger.info(\"Correo con adjunto enviado a: {}\", to);\n        } catch (MessagingException | MailException e) {\n            logger.error(\"Error al enviar el correo con adjunto: {}\", e.getMessage());\n        }\n    }\n}\n</code></pre> <p>En este ejemplo, se manejan diferentes tipos de excepciones de correo para proporcionar mensajes de error m\u00e1s espec\u00edficos y se utiliza un Logger para registrar eventos importantes.</p>"}]}