{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentaci\u00f3n del Proyecto Spring Demo","text":"<p>Bienvenido a la documentaci\u00f3n del proyecto Spring Demo. Aqu\u00ed encontrar\u00e1s informaci\u00f3n detallada sobre c\u00f3mo configurar, desarrollar y desplegar aplicaciones utilizando Spring Boot y sus m\u00f3dulos asociados.</p>"},{"location":"#indice","title":"\u00cdndice","text":"<ol> <li>Introducci\u00f3n a Spring Boot y conceptos clave</li> <li>Configuraci\u00f3n del Proyecto</li> <li>Introducci\u00f3n a Spring Web</li> <li>Gesti\u00f3n de Datos y L\u00f3gica de Negocio con Spring Data</li> <li>Seguridad con Spring Security y JWT</li> <li>Documentaci\u00f3n con Swagger</li> <li>Implementaci\u00f3n de Servicios en Red</li> <li>Pruebas y Depuraci\u00f3n</li> <li>Introducci\u00f3n a la programaci\u00f3n distribuida</li> <li>Despliegue de Aplicaciones Spring Boot en Entornos de Producci\u00f3n</li> </ol>"},{"location":"0_introduccion/","title":"Introducci\u00f3n a Spring Boot y conceptos clave","text":""},{"location":"0_introduccion/#introduccion-a-conceptos-basicos-de-spring","title":"Introducci\u00f3n a Conceptos B\u00e1sicos de Spring","text":""},{"location":"0_introduccion/#que-es-spring","title":"\u00bfQu\u00e9 es Spring?","text":"<p>Spring es un framework de c\u00f3digo abierto para el desarrollo de aplicaciones en Java que promueve buenas pr\u00e1cticas de dise\u00f1o. Su prop\u00f3sito principal es reducir la complejidad en la configuraci\u00f3n y el desarrollo de aplicaciones empresariales, permitiendo a los desarrolladores centrarse en la l\u00f3gica de negocio.</p> <p>Spring es muy vers\u00e1til y se puede usar para desarrollar aplicaciones de cualquier tipo, desde simples herramientas hasta sistemas empresariales complejos.</p>"},{"location":"0_introduccion/#framework-vs-libreria","title":"Framework vs. Librer\u00eda","text":"<p>Un framework como Spring establece un conjunto de reglas y estructuras que el desarrollador debe seguir, ofreciendo flexibilidad pero tambi\u00e9n direcci\u00f3n. A diferencia de una librer\u00eda, que simplemente provee funciones reutilizables, un framework como Spring organiza y gestiona el flujo de control de la aplicaci\u00f3n.</p>"},{"location":"0_introduccion/#historia-de-spring","title":"Historia de Spring","text":"<p>Spring fue creado en 2003 por Rod Johnson como una alternativa m\u00e1s sencilla y modular a las especificaciones complejas de Java EE. Su objetivo inicial era facilitar el desarrollo de aplicaciones empresariales al proporcionar un enfoque m\u00e1s ligero y flexible.</p>"},{"location":"0_introduccion/#introduccion-a-spring-boot","title":"Introducci\u00f3n a Spring Boot","text":"<p>Spring Boot es una extensi\u00f3n del framework Spring dise\u00f1ada para simplificar el desarrollo y despliegue de aplicaciones. Es ideal tanto para principiantes como para desarrolladores experimentados que deseen reducir la complejidad de configuraci\u00f3n.</p>"},{"location":"0_introduccion/#caracteristicas-principales","title":"Caracter\u00edsticas principales","text":"<ul> <li>Configuraci\u00f3n autom\u00e1tica: Spring Boot configura autom\u00e1ticamente los componentes necesarios en funci\u00f3n de las dependencias incluidas en el proyecto.</li> <li>Servidores embebidos: Integraci\u00f3n con servidores como Tomcat o Jetty, lo que elimina la necesidad de configurarlos externamente.</li> <li>Aplicaciones listas para producci\u00f3n: Incluye herramientas para monitoreo, m\u00e9tricas y an\u00e1lisis de rendimiento.</li> </ul>"},{"location":"0_introduccion/#ejemplo-practico-hello-world","title":"Ejemplo pr\u00e1ctico: \"Hello World\"","text":"<pre><code>@SpringBootApplication\npublic class HelloWorldApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(HelloWorldApplication.class, args);\n    }\n}\n</code></pre>"},{"location":"0_introduccion/#uso-de-spring-initializr","title":"Uso de Spring Initializr","text":"<p>Spring Initializr es una herramienta que permite generar proyectos Spring Boot con las dependencias necesarias. Aqu\u00ed se explica c\u00f3mo utilizar Spring Initializr para crear un nuevo proyecto:</p> <ul> <li> <p>Acceder a Spring Initializr:</p> <ul> <li>Abre un navegador web y navega a Spring Initializr.</li> </ul> </li> <li> <p>Configurar el Proyecto:</p> <ul> <li>Selecciona las opciones de configuraci\u00f3n del proyecto, como el nombre del grupo, el nombre del artefacto, la versi\u00f3n de Java, etc.</li> <li>A\u00f1ade las dependencias necesarias, como <code>Spring Web</code>, <code>Spring Data JPA</code>, <code>Spring Boot DevTools</code>, etc. Por ahora basta con Spring Web.</li> </ul> </li> <li> <p>Generar el Proyecto:</p> <ul> <li>Haz clic en el bot\u00f3n \"Generate\" para descargar el proyecto generado.</li> <li>Descomprime el archivo descargado y abre el proyecto en tu IDE favorito.</li> </ul> </li> </ul>"},{"location":"0_introduccion/#principales-proyectos-de-spring","title":"Principales Proyectos de Spring","text":""},{"location":"0_introduccion/#spring-boot","title":"Spring Boot","text":"<p>Spring Boot es una herramienta que simplifica significativamente el desarrollo con Spring, eliminando la necesidad de configuraciones extensas y repetitivas. Est\u00e1 dise\u00f1ado para agilizar la creaci\u00f3n de aplicaciones listas para producci\u00f3n, especialmente en entornos de microservicios.</p>"},{"location":"0_introduccion/#spring-web","title":"Spring Web","text":"<p>Spring Web es un m\u00f3dulo de Spring que facilita la creaci\u00f3n de aplicaciones web y servicios RESTful. Proporciona soporte para controladores, vistas y modelos, y permite manejar solicitudes HTTP de manera sencilla.</p>"},{"location":"0_introduccion/#caracteristicas-principales_1","title":"Caracter\u00edsticas principales","text":"<ul> <li>Controladores RESTful: Facilita la creaci\u00f3n de APIs RESTful mediante anotaciones como <code>@RestController</code>.</li> <li>Manejo de solicitudes HTTP: Permite manejar solicitudes HTTP GET, POST, PUT, DELETE, etc.</li> <li>Soporte para vistas: Integra con tecnolog\u00edas de vistas como Thymeleaf, JSP, etc.</li> </ul>"},{"location":"0_introduccion/#spring-data","title":"Spring Data","text":"<p>Spring Data facilita la interacci\u00f3n con bases de datos mediante la definici\u00f3n de repositorios que encapsulan las operaciones CRUD y consultas personalizadas. Su objetivo es reducir la cantidad de c\u00f3digo repetitivo en las capas de acceso a datos.</p>"},{"location":"0_introduccion/#caracteristicas-principales_2","title":"Caracter\u00edsticas principales","text":"<ul> <li>Repositorios predefinidos: Proporciona interfaces como <code>JpaRepository</code> que permiten realizar operaciones est\u00e1ndar sin necesidad de implementaci\u00f3n manual.</li> <li>Consultas personalizadas: Permite definir consultas espec\u00edficas mediante nombres de m\u00e9todos o anotaciones como <code>@Query</code>.</li> <li>Compatibilidad con m\u00faltiples bases de datos: Incluye soporte para MySQL, PostgreSQL, MongoDB, Cassandra, entre otras.</li> <li>Auditor\u00eda: Proporciona soporte para auditor\u00eda de entidades, permitiendo rastrear cambios en los datos.</li> <li>Paginaci\u00f3n y ordenaci\u00f3n: Facilita la paginaci\u00f3n y ordenaci\u00f3n de resultados de consultas.</li> </ul>"},{"location":"0_introduccion/#spring-security","title":"Spring Security","text":"<p>Spring Security es un marco que proporciona herramientas avanzadas para garantizar la autenticaci\u00f3n, autorizaci\u00f3n y protecci\u00f3n contra ataques comunes en aplicaciones Java.</p>"},{"location":"0_introduccion/#caracteristicas-principales_3","title":"Caracter\u00edsticas principales","text":"<ul> <li>Gesti\u00f3n de roles y permisos: Controla el acceso a diferentes partes de la aplicaci\u00f3n seg\u00fan roles definidos.</li> <li>Protecci\u00f3n avanzada: Incluye medidas contra ataques de fuerza bruta, CSRF y XSS.</li> <li>Compatibilidad: Funciona con autenticaci\u00f3n tradicional basada en formularios y sistemas modernos como OAuth2 o JWT.</li> <li>Integraci\u00f3n con Spring Boot: Se integra f\u00e1cilmente con aplicaciones Spring Boot para proporcionar seguridad de manera r\u00e1pida y sencilla.</li> <li>Personalizaci\u00f3n: Permite personalizar la configuraci\u00f3n de seguridad seg\u00fan las necesidades espec\u00edficas de la aplicaci\u00f3n.</li> </ul>"},{"location":"0_introduccion/#spring-cloud","title":"Spring Cloud","text":"<p>Spring Cloud extiende las funcionalidades de Spring para abordar los desaf\u00edos de arquitecturas distribuidas y microservicios. Este marco se enfoca en la gesti\u00f3n de configuraci\u00f3n, descubrimiento de servicios, balanceo de carga y comunicaci\u00f3n entre servicios.</p>"},{"location":"0_introduccion/#caracteristicas-principales_4","title":"Caracter\u00edsticas principales","text":"<ul> <li>Gesti\u00f3n de configuraci\u00f3n: Centraliza la configuraci\u00f3n de aplicaciones distribuidas.</li> <li>Descubrimiento de servicios: Permite que los servicios se registren y descubran entre s\u00ed.</li> <li>Balanceo de carga: Distribuye el tr\u00e1fico de manera equitativa entre instancias de servicios.</li> <li>Comunicaci\u00f3n entre servicios: Facilita la comunicaci\u00f3n entre servicios mediante herramientas como Feign y Ribbon.</li> </ul>"},{"location":"0_introduccion/#material-avanzado","title":"Material Avanzado","text":""},{"location":"0_introduccion/#configuracion-avanzada-de-spring-boot","title":"Configuraci\u00f3n Avanzada de Spring Boot","text":"<p>Spring Boot permite configurar perfiles y gestionar propiedades externas, adapt\u00e1ndose a diferentes entornos (desarrollo, producci\u00f3n, etc.). Estas configuraciones avanzadas facilitan el despliegue y la administraci\u00f3n de aplicaciones.</p>"},{"location":"0_introduccion/#configuracion-de-perfiles","title":"Configuraci\u00f3n de Perfiles","text":"<p>Los perfiles permiten personalizar la configuraci\u00f3n seg\u00fan el entorno.</p> <ul> <li> <p>Archivos de Configuraci\u00f3n por Perfil:</p> <ul> <li>Cada perfil tiene su propio archivo, como application-dev.properties y application-prod.properties. Ejemplo:</li> <li>Archivo para desarrollo (application-dev.properties): <pre><code># application-dev.properties\nserver.port=8081\nspring.datasource.url=jdbc:h2:mem:devdb\n</code></pre></li> <li>Archivo para producci\u00f3n (application-prod.properties): <pre><code># application-prod.properties\nserver.port=8080\nspring.datasource.url=jdbc:mysql://localhost/proddb\n</code></pre></li> </ul> </li> <li> <p>Activar un Perfil:</p> <ul> <li>Selecciona el perfil deseado configurando la propiedad <code>spring.profiles.active</code> en el archivo <code>application.properties</code> o mediante una variable de entorno. <pre><code># application.properties\nspring.profiles.active=dev\n</code></pre></li> </ul> </li> </ul>"},{"location":"0_introduccion/#configuracion-de-propiedades-externas","title":"Configuraci\u00f3n de Propiedades Externas","text":"<p>Spring Boot permite cargar propiedades desde archivos externos o variables de entorno.</p> <ul> <li>Cargar Propiedades desde un Archivo Externo:<ul> <li>Especificar la ubicaci\u00f3n del archivo de propiedades externo utilizando la propiedad <code>spring.config.location</code>.</li> </ul> </li> </ul> <pre><code># application.properties\nspring.config.location=classpath:/config/application-external.properties\n</code></pre> <ul> <li>Utilizar Variables de Entorno:<ul> <li>Definir variables de entorno en el sistema operativo y acceder a ellas en el archivo de configuraci\u00f3n.</li> </ul> </li> </ul> <pre><code># application.properties\nspring.datasource.url=${DATASOURCE_URL}\n</code></pre>"},{"location":"0_introduccion/#monitoreo-y-metricas","title":"Monitoreo y M\u00e9tricas","text":"<p>Spring Boot Actuator proporciona funcionalidades para monitorear y gestionar aplicaciones en producci\u00f3n. Aqu\u00ed se explica c\u00f3mo habilitar y configurar Actuator.</p>"},{"location":"0_introduccion/#habilitar-actuator","title":"Habilitar Actuator","text":"<ul> <li> <p>Agregar la Dependencia de Actuator:</p> <ul> <li>A\u00f1adir la dependencia <code>spring-boot-starter-actuator</code> en el archivo <code>pom.xml</code>. <pre><code>&lt;dependency&gt;\n      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre></li> </ul> </li> <li> <p>Configurar Actuator:</p> <ul> <li>Configurar Actuator en el archivo <code>application.properties</code>. <pre><code>management.endpoints.web.exposure.include=*\nmanagement.endpoint.health.show-details=always\n</code></pre></li> </ul> </li> </ul>"},{"location":"0_introduccion/#monitoreo-de-la-salud-de-la-aplicacion","title":"Monitoreo de la Salud de la Aplicaci\u00f3n","text":"<p>Actuator proporciona un endpoint <code>/actuator/health</code> para monitorear la salud de la aplicaci\u00f3n.</p> <ul> <li>Acceder al Endpoint de Salud:<ul> <li>Iniciar la aplicaci\u00f3n Spring Boot.</li> <li>Acceder al endpoint de salud en <code>http://localhost:8080/actuator/health</code>.</li> </ul> </li> </ul>"},{"location":"0_introduccion/#metricas-de-rendimiento","title":"M\u00e9tricas de Rendimiento","text":"<p>Actuator proporciona un endpoint <code>/actuator/metrics</code> para acceder a m\u00e9tricas de rendimiento.</p> <ul> <li>Acceder al Endpoint de M\u00e9tricas:<ul> <li>Iniciar la aplicaci\u00f3n Spring Boot.</li> <li>Acceder al endpoint de m\u00e9tricas en <code>http://localhost:8080/actuator/metrics</code>.</li> </ul> </li> </ul>"},{"location":"0_introduccion/#explicacion-del-codigo","title":"Explicaci\u00f3n del C\u00f3digo","text":"<ul> <li><code>spring.profiles.active</code>: Propiedad utilizada para activar un perfil espec\u00edfico.</li> <li><code>spring.config.location</code>: Propiedad utilizada para especificar la ubicaci\u00f3n de un archivo de propiedades externo.</li> <li><code>management.endpoints.web.exposure.include</code>: Propiedad utilizada para exponer todos los endpoints de Actuator.</li> <li><code>management.endpoint.health.show-details</code>: Propiedad utilizada para mostrar detalles en el endpoint de salud.</li> </ul>"},{"location":"0_introduccion/#beneficios-de-usar-actuator","title":"Beneficios de Usar Actuator","text":"<ul> <li>Monitoreo en Tiempo Real: Proporciona informaci\u00f3n en tiempo real sobre la salud y el rendimiento de la aplicaci\u00f3n.</li> <li>Gesti\u00f3n Simplificada: Facilita la gesti\u00f3n de aplicaciones en producci\u00f3n mediante endpoints de administraci\u00f3n.</li> <li>Integraci\u00f3n con Herramientas de Monitoreo: Se integra f\u00e1cilmente con herramientas de monitoreo como Prometheus y Grafana.</li> </ul>"},{"location":"0_introduccion/#actividad-practica","title":"Actividad Pr\u00e1ctica","text":"<ul> <li> <p>Configurar Perfiles en Spring Boot:</p> <ul> <li>Crear archivos de configuraci\u00f3n espec\u00edficos para cada perfil.</li> <li>Activar un perfil espec\u00edfico utilizando la propiedad <code>spring.profiles.active</code>.</li> </ul> </li> <li> <p>Habilitar y Configurar Actuator:</p> <ul> <li>A\u00f1adir la dependencia <code>spring-boot-starter-actuator</code>.</li> <li>Configurar Actuator en el archivo <code>application.properties</code>.</li> <li>Acceder a los endpoints de salud y m\u00e9tricas para monitorear la aplicaci\u00f3n.</li> </ul> </li> </ul>"},{"location":"1_configuracion/","title":"Configuraci\u00f3n del Proyecto","text":""},{"location":"1_configuracion/#capitulo-1-introduccion-a-spring-boot-y-configuracion-del-proyecto","title":"Cap\u00edtulo 1: Introducci\u00f3n a Spring Boot y Configuraci\u00f3n del Proyecto","text":""},{"location":"1_configuracion/#introduccion","title":"Introducci\u00f3n","text":"<p>Spring Boot es un framework que facilita la creaci\u00f3n de aplicaciones Java basadas en Spring. Proporciona configuraci\u00f3n autom\u00e1tica y servidores embebidos, lo que permite desarrollar aplicaciones r\u00e1pidamente.</p>"},{"location":"1_configuracion/#actividad-practica","title":"Actividad Pr\u00e1ctica","text":"<ul> <li> <p>Crear un proyecto Spring Boot:</p> <ul> <li>Utiliza Spring Initializr para crear un nuevo proyecto llamado \"spring-demo\" con las dependencias necesarias, por ejemplo, puedes a\u00f1adir Spring Web.</li> </ul> </li> <li> <p>Estructura del Proyecto y Explicaci\u00f3n de Componentes:</p> <ul> <li>src/main/java: Contiene el c\u00f3digo fuente de la aplicaci\u00f3n.<ul> <li>com.example.springdemo: Paquete base donde se encuentra la clase principal.</li> <li>SpringDemoApplication.java: Clase principal de la aplicaci\u00f3n con la anotaci\u00f3n <code>@SpringBootApplication</code>. <pre><code>@SpringBootApplication\npublic class SpringDemoApplication {\n    private static final Logger logger = LoggerFactory.getLogger(SpringDemoApplication.class);\n\n    public static void main(String[] args) {\n        logger.info(\"Iniciando la aplicaci\u00f3n Spring Boot\");\n        SpringApplication.run(SpringDemoApplication.class, args);\n        logger.info(\"Aplicaci\u00f3n Spring Boot iniciada\");\n    }\n}\n</code></pre>  La anotaci\u00f3n <code>@SpringBootApplication</code> es una combinaci\u00f3n de tres anotaciones: <code>@Configuration</code>, <code>@EnableAutoConfiguration</code>, y <code>@ComponentScan</code>. Esta anotaci\u00f3n marca la clase como la principal para la configuraci\u00f3n de Spring Boot. El m\u00e9todo <code>main</code> utiliza <code>SpringApplication.run</code> para lanzar la aplicaci\u00f3n.</li> </ul> </li> </ul> </li> <li> <p>src/main/resources: Contiene recursos est\u00e1ticos y archivos de configuraci\u00f3n.</p> <ul> <li>application.properties: Archivo de configuraci\u00f3n de la aplicaci\u00f3n. <pre><code># Configuraci\u00f3n de ejemplo\nserver.port=8080\nspring.application.name=spring-demo\n</code></pre>  El archivo <code>application.properties</code> se utiliza para configurar diversas propiedades de la aplicaci\u00f3n, como el puerto del servidor y el nombre de la aplicaci\u00f3n.</li> </ul> </li> <li> <p>src/test/java: Contiene las pruebas unitarias de la aplicaci\u00f3n.</p> </li> <li> <p>pom.xml: Archivo de configuraci\u00f3n de Maven que gestiona las dependencias del proyecto. <pre><code>&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;!-- Otras dependencias --&gt;\n&lt;/dependencies&gt;\n</code></pre> El archivo <code>pom.xml</code> es utilizado por Maven para gestionar las dependencias del proyecto. En este ejemplo, se incluye la dependencia <code>spring-boot-starter-web</code> para a\u00f1adir soporte para aplicaciones web.</p> </li> <li> <p>Poner en ejecuci\u00f3n el proyecto:</p> <ul> <li>Abre una terminal en el directorio ra\u00edz del proyecto.</li> <li>Ejecuta el siguiente comando para compilar y ejecutar la aplicaci\u00f3n:</li> </ul> </li> </ul> <p><pre><code>./mvnw spring-boot:run\n</code></pre>    - La aplicaci\u00f3n estar\u00e1 disponible en <code>http://localhost:8080</code>.</p>"},{"location":"1_configuracion/#uso-de-logger-en-spring-boot","title":"Uso de Logger en Spring Boot","text":"<p>Logger es una herramienta clave en el desarrollo de aplicaciones, ya que permite registrar eventos importantes, diagn\u00f3sticos y errores. En Spring Boot, el sistema de registro predeterminado utiliza SLF4J como interfaz y Logback como implementaci\u00f3n predeterminada.</p> <p>No es necesario agregar expl\u00edcitamente las dependencias de SLF4J y Logback en el archivo pom.xml cuando trabajas con Spring Boot. Estas ya est\u00e1n incluidas autom\u00e1ticamente a trav\u00e9s de los starters. Por ejemplo, al agregar el siguiente starter:</p> <p><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> Spring Boot incluir\u00e1 de manera transitiva: <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;\n    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> Los starters simplifican la gesti\u00f3n de dependencias, aseguran compatibilidad entre librer\u00edas relacionadas y ofrecen flexibilidad para cambiar implementaciones seg\u00fan las necesidades del proyecto.</p> <ul> <li>Configurar el Logger en una clase de servicio: <pre><code>import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class ExampleService {\n    private static final Logger logger = LoggerFactory.getLogger(ExampleService.class);\n\n    public void exampleMethod() {\n        logger.info(\"M\u00e9todo exampleMethod ejecutado\");\n        logger.debug(\"Debugging exampleMethod\");\n        try {\n            // ...existing code...\n        } catch (Exception e) {\n            logger.error(\"Error en exampleMethod: {}\", e.getMessage());\n        }\n    }\n}\n</code></pre></li> </ul>"},{"location":"1_configuracion/#configuracion-de-niveles-de-registro-en-applicationproperties","title":"Configuraci\u00f3n de Niveles de Registro en <code>application.properties</code>","text":"<p>Spring Boot utiliza SLF4J como interfaz de registro y Logback como la implementaci\u00f3n predeterminada. Puedes configurar los niveles de registro para diferentes paquetes y clases en el archivo <code>application.properties</code>. Los niveles de registro disponibles son: <code>TRACE</code>, <code>DEBUG</code>, <code>INFO</code>, <code>WARN</code>, <code>ERROR</code>, <code>FATAL</code>, y <code>OFF</code>.</p> <p>Para configurar diferentes niveles de registro en <code>application.properties</code>, a\u00f1ade las siguientes propiedades:</p> <pre><code># Configura el nivel de registro global para toda la aplicaci\u00f3n\nlogging.level.root=INFO\n\n# Configura el nivel de registro para un paquete espec\u00edfico\nlogging.level.com.example.springdemo=DEBUG\n\n# Configura el archivo donde se almacenar\u00e1n los registros\nlogging.file.name=logs/spring-demo.log\n</code></pre> <ul> <li><code>logging.level.root=INFO</code>: Establece el nivel de registro global en <code>INFO</code>. Esto significa que todos los mensajes de registro con un nivel de <code>INFO</code> o superior (WARN, ERROR) ser\u00e1n registrados.</li> <li><code>logging.level.com.example.springdemo=DEBUG</code>: Establece el nivel de registro para el paquete <code>com.example.springdemo</code> en <code>DEBUG</code>. Esto es \u00fatil para obtener m\u00e1s detalles durante el desarrollo y la depuraci\u00f3n.</li> <li><code>logging.file.name=logs/spring-demo.log</code>: Especifica el archivo donde se almacenar\u00e1n los registros. En este caso, los registros se guardar\u00e1n en <code>logs/spring-demo.log</code>.</li> </ul> <p>Estas configuraciones te permiten controlar la cantidad de informaci\u00f3n de registro generada por tu aplicaci\u00f3n y dirigirla a archivos espec\u00edficos para su an\u00e1lisis.</p>"},{"location":"1_configuracion/#ejemplos-de-pruebas-unitarias","title":"Ejemplos de Pruebas Unitarias","text":"<p>Las pruebas unitarias son esenciales para asegurar que el c\u00f3digo funcione correctamente y para detectar errores de manera temprana. Aqu\u00ed se muestra c\u00f3mo escribir y ejecutar pruebas unitarias en Spring Boot:</p> <ul> <li> <p>Agregar Dependencias de Pruebas en <code>pom.xml</code>: <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre></p> </li> <li> <p>Escribir una Prueba Unitaria para un Controlador: <pre><code>import org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\nimport org.springframework.test.web.servlet.MockMvc;\n\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@WebMvcTest(HolaMundoController.class)\npublic class HolaMundoControllerTest {\n\n    @Autowired\n    private MockMvc mockMvc;\n\n    @Test\n    public void testHolaMundo() throws Exception {\n        mockMvc.perform(get(\"/api/hola\"))\n                .andExpect(status().isOk())\n                .andExpect(content().string(\"Hola Mundo\"));\n    }\n}\n</code></pre></p> </li> <li> <p>Escribir una Prueba Unitaria para un Servicio: <pre><code>import org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n@SpringBootTest\npublic class ExampleServiceTest {\n\n    @Autowired\n    private ExampleService exampleService;\n\n    @Test\n    public void testExampleMethod() {\n        exampleService.exampleMethod();\n        // Verificar el comportamiento esperado\n        assertThat(true).isTrue();\n    }\n}\n</code></pre></p> </li> </ul>"},{"location":"1_configuracion/#explicacion-del-codigo","title":"Explicaci\u00f3n del C\u00f3digo","text":"<ul> <li><code>@SpringBootApplication</code>: Esta anotaci\u00f3n es una combinaci\u00f3n de tres anotaciones: <code>@Configuration</code>, <code>@EnableAutoConfiguration</code>, y <code>@ComponentScan</code>. Marca la clase como la principal para la configuraci\u00f3n de Spring Boot.</li> <li><code>SpringApplication.run(SpringDemoApplication.class, args)</code>: Este m\u00e9todo lanza la aplicaci\u00f3n Spring Boot.</li> <li><code>Logger</code>: Utilizado para registrar eventos importantes y errores en la aplicaci\u00f3n.</li> <li><code>@WebMvcTest</code>: Anotaci\u00f3n utilizada para pruebas unitarias de controladores.</li> <li><code>MockMvc</code>: Utilizado para realizar solicitudes HTTP simuladas en pruebas unitarias.</li> <li><code>@SpringBootTest</code>: Anotaci\u00f3n utilizada para pruebas unitarias de servicios.</li> </ul>"},{"location":"1_configuracion/#beneficios-de-usar-spring-boot","title":"Beneficios de Usar Spring Boot","text":"<ul> <li>Configuraci\u00f3n Autom\u00e1tica: Spring Boot configura autom\u00e1ticamente los componentes necesarios en funci\u00f3n de las dependencias incluidas en el proyecto.</li> <li>Servidores Embebidos: Integraci\u00f3n con servidores como Tomcat o Jetty, lo que elimina la necesidad de configurarlos externamente.</li> <li>Aplicaciones Listas para Producci\u00f3n: Incluye herramientas para monitoreo, m\u00e9tricas y an\u00e1lisis de rendimiento.</li> </ul>"},{"location":"1_configuracion/#actividad-practica_1","title":"Actividad Pr\u00e1ctica","text":"<ul> <li>Explorar la Estructura del Proyecto:<ul> <li>Navegar por los directorios y archivos del proyecto para familiarizarse con la estructura del proyecto Spring Boot.</li> <li>Revisar el archivo <code>application.properties</code> y agregar configuraciones adicionales seg\u00fan sea necesario.</li> </ul> </li> </ul>"},{"location":"1_configuracion/#posibles-errores-comunes","title":"Posibles Errores Comunes","text":"<ul> <li> <p>Error de Conexi\u00f3n al Servidor:</p> <ul> <li>Soluci\u00f3n: Verificar que el puerto configurado en <code>application.properties</code> no est\u00e9 en uso por otra aplicaci\u00f3n.</li> </ul> </li> <li> <p>Dependencias:</p> <ul> <li>Soluci\u00f3n: Asegurarse de que todas las dependencias necesarias est\u00e9n incluidas en el archivo <code>pom.xml</code> y ejecutar <code>mvn clean install</code> para actualizar el proyecto.</li> </ul> </li> </ul>"},{"location":"2_spring_web/","title":"Introducci\u00f3n a Spring Web","text":""},{"location":"2_spring_web/#capitulo-2-introduccion-a-spring-web","title":"Cap\u00edtulo 2: Introducci\u00f3n a Spring Web","text":""},{"location":"2_spring_web/#introduccion","title":"Introducci\u00f3n","text":"<p>Spring Web es un m\u00f3dulo de Spring que facilita la creaci\u00f3n de aplicaciones web y servicios RESTful. Proporciona soporte para controladores, vistas y modelos, y permite manejar solicitudes HTTP de manera sencilla.</p>"},{"location":"2_spring_web/#principales-anotaciones","title":"Principales Anotaciones","text":"<ul> <li><code>@RestController</code>: Indica que la clase es un controlador RESTful.</li> <li><code>@RequestMapping</code>: Mapea solicitudes HTTP a m\u00e9todos espec\u00edficos en un controlador.</li> <li><code>@GetMapping</code>: Maneja solicitudes HTTP GET.</li> <li><code>@PostMapping</code>: Maneja solicitudes HTTP POST.</li> <li><code>@PutMapping</code>: Maneja solicitudes HTTP PUT.</li> <li><code>@DeleteMapping</code>: Maneja solicitudes HTTP DELETE.</li> <li><code>@PathVariable</code>: Vincula una variable de ruta a un par\u00e1metro de m\u00e9todo.</li> <li><code>@RequestParam</code>: Vincula un par\u00e1metro de solicitud a un par\u00e1metro de m\u00e9todo.</li> <li><code>@RequestBody</code>: Vincula el cuerpo de una solicitud a un par\u00e1metro de m\u00e9todo.</li> </ul>"},{"location":"2_spring_web/#ejemplos-de-anotaciones","title":"Ejemplos de Anotaciones","text":"<pre><code>@RestController\n@RequestMapping(\"/api\")\npublic class ExampleController {\n    private static final Logger logger = LoggerFactory.getLogger(ExampleController.class);\n\n    @GetMapping(\"/hello\")\n    public String sayHello() {\n        logger.info(\"sayHello endpoint llamado\");\n        return \"Hello, World!\";\n    }\n\n    @RequestMapping(value = \"/greet\", method = RequestMethod.GET)\n    public String greet() {\n        logger.info(\"greet endpoint llamado\");\n        return \"Greetings!\";\n    }\n\n    @PostMapping(\"/create\")\n    public String create(@RequestBody String data) {\n        logger.info(\"create endpoint llamado con datos: {}\", data);\n        return \"Data created: \" + data;\n    }\n\n    @PutMapping(\"/update\")\n    public String update(@RequestBody String data) {\n        logger.info(\"update endpoint llamado con datos: {}\", data);\n        return \"Data updated: \" + data;\n    }\n\n    @DeleteMapping(\"/delete/{id}\")\n    public String delete(@PathVariable Long id) {\n        logger.info(\"delete endpoint llamado con id: {}\", id);\n        return \"Data deleted with id: \" + id;\n    }\n\n    @GetMapping(\"/user/{id}\")\n    public String getUser(@PathVariable Long id) {\n        logger.info(\"getUser endpoint llamado con id: {}\", id);\n        return \"User ID: \" + id;\n    }\n\n    @GetMapping(\"/search\")\n    public String search(@RequestParam String query) {\n        logger.info(\"search endpoint llamado con query: {}\", query);\n        return \"Search query: \" + query;\n    }\n\n    @PostMapping(\"/add\")\n    public String add(@RequestBody String data) {\n        logger.info(\"add endpoint llamado con datos: {}\", data);\n        return \"Data added: \" + data;\n    }\n}\n</code></pre>"},{"location":"2_spring_web/#explicacion-del-codigo","title":"Explicaci\u00f3n del C\u00f3digo","text":"<ul> <li><code>@RestController</code>: Indica que la clase es un controlador RESTful.</li> <li><code>@RequestMapping</code>: Mapea solicitudes HTTP a m\u00e9todos espec\u00edficos en un controlador.</li> <li><code>@GetMapping</code>: Maneja solicitudes HTTP GET.</li> <li><code>@PostMapping</code>: Maneja solicitudes HTTP POST.</li> <li><code>@PutMapping</code>: Maneja solicitudes HTTP PUT.</li> <li><code>@DeleteMapping</code>: Maneja solicitudes HTTP DELETE.</li> <li><code>@PathVariable</code>: Vincula una variable de ruta a un par\u00e1metro de m\u00e9todo.</li> <li><code>@RequestParam</code>: Vincula un par\u00e1metro de solicitud a un par\u00e1metro de m\u00e9todo.</li> <li><code>@RequestBody</code>: Vincula el cuerpo de una solicitud a un par\u00e1metro de m\u00e9todo.</li> <li><code>Logger</code>: Utilizado para registrar eventos importantes y errores en la aplicaci\u00f3n.</li> </ul>"},{"location":"2_spring_web/#actividad-practica","title":"Actividad Pr\u00e1ctica","text":"<ul> <li>Crear un servicio REST \"Hola Mundo\":<ul> <li>Crear un controlador RESTful que maneje una solicitud GET y devuelva un mensaje \"Hola Mundo\".</li> </ul> </li> </ul> <pre><code>@RestController\n@RequestMapping(\"/api\")\npublic class HolaMundoController {\n    private static final Logger logger = LoggerFactory.getLogger(HolaMundoController.class);\n\n    @GetMapping(\"/hola\")\n    public String holaMundo() {\n        logger.info(\"holaMundo endpoint llamado\");\n        return \"Hola Mundo\";\n    }\n}\n</code></pre>"},{"location":"2_spring_web/#ejemplo-practico","title":"Ejemplo Pr\u00e1ctico","text":"<ul> <li>Crear un controlador RESTful que maneje una solicitud POST con par\u00e1metros y cuerpo:<ul> <li>Crear un controlador RESTful que maneje una solicitud POST, reciba par\u00e1metros en la URL y un cuerpo en la solicitud.</li> </ul> </li> </ul> <pre><code>@RestController\n@RequestMapping(\"/api\")\npublic class ComplexController {\n    private static final Logger logger = LoggerFactory.getLogger(ComplexController.class);\n\n    @PostMapping(\"/process\")\n    public ResponseEntity&lt;String&gt; processRequest(\n            @RequestParam String param,\n            @RequestBody Map&lt;String, Object&gt; body) {\n        logger.info(\"processRequest endpoint llamado con param: {} y body: {}\", param, body);\n        String response = \"Received param: \" + param + \" and body: \" + body.toString();\n        return ResponseEntity.ok(response);\n    }\n}\n</code></pre>"},{"location":"2_spring_web/#explicacion-del-codigo_1","title":"Explicaci\u00f3n del C\u00f3digo","text":"<ul> <li><code>@RestController</code>: Indica que la clase es un controlador RESTful.</li> <li><code>@RequestMapping(\"/api\")</code>: Mapea las solicitudes HTTP a la ruta base <code>/api</code>.</li> <li><code>@PostMapping(\"/process\")</code>: Maneja las solicitudes HTTP POST a la ruta <code>/api/process</code>.</li> <li><code>@RequestParam String param</code>: Vincula un par\u00e1metro de solicitud a un par\u00e1metro de m\u00e9todo.</li> <li><code>@RequestBody Map&lt;String, Object&gt; body</code>: Vincula el cuerpo de una solicitud a un par\u00e1metro de m\u00e9todo.</li> <li><code>ResponseEntity&lt;String&gt;</code>: Representa la respuesta HTTP con un cuerpo de tipo <code>String</code>.</li> <li><code>Logger</code>: Utilizado para registrar eventos importantes y errores en la aplicaci\u00f3n.</li> </ul>"},{"location":"2_spring_web/#actividad-practica_1","title":"Actividad Pr\u00e1ctica","text":"<ul> <li>Probar el Controlador RESTful:<ul> <li>Iniciar la aplicaci\u00f3n Spring Boot.</li> <li>Utilizar una herramienta como Postman para enviar una solicitud POST a <code>http://localhost:8080/api/process</code> con un par\u00e1metro <code>param</code> y un cuerpo JSON. <pre><code>{\n    \"key1\": \"value1\",\n    \"key2\": \"value2\"\n}\n</code></pre></li> <li>Verificar que la respuesta incluya tanto el par\u00e1metro como el cuerpo de la solicitud.</li> </ul> </li> </ul>"},{"location":"2_spring_web/#beneficios-de-usar-spring-web","title":"Beneficios de Usar Spring Web","text":"<ul> <li>Facilidad de Uso: Spring Web proporciona anotaciones que simplifican la creaci\u00f3n de controladores y el manejo de solicitudes HTTP.</li> <li>Flexibilidad: Permite manejar diferentes tipos de solicitudes HTTP (GET, POST, PUT, DELETE) y vincular par\u00e1metros de solicitud y variables de ruta a m\u00e9todos de controlador.</li> <li>Integraci\u00f3n con Spring Boot: Se integra f\u00e1cilmente con aplicaciones Spring Boot, lo que facilita su configuraci\u00f3n y uso.</li> </ul>"},{"location":"2_spring_web/#actividad-practica_2","title":"Actividad Pr\u00e1ctica","text":"<ul> <li>Probar el Servicio REST \"Hola Mundo\":<ul> <li>Iniciar la aplicaci\u00f3n Spring Boot.</li> <li>Utilizar un navegador web o una herramienta como Postman para enviar una solicitud GET a <code>http://localhost:8080/api/hola</code>.</li> <li>Verificar que la respuesta sea \"Hola Mundo\".</li> </ul> </li> </ul>"},{"location":"2_spring_web/#validaciones-en-spring-boot","title":"Validaciones en Spring Boot","text":""},{"location":"2_spring_web/#introduccion-a-las-validaciones-en-spring-boot","title":"Introducci\u00f3n a las Validaciones en Spring Boot","text":"<p>Spring Boot proporciona soporte para validaciones utilizando la especificaci\u00f3n Bean Validation (JSR 380). Esto permite validar datos de entrada en controladores, servicios y entidades de manera sencilla y declarativa.</p>"},{"location":"2_spring_web/#configuracion-de-dependencias","title":"Configuraci\u00f3n de Dependencias","text":"<p>Para utilizar las validaciones en Spring Boot, es necesario a\u00f1adir la dependencia <code>spring-boot-starter-validation</code> en el archivo <code>pom.xml</code>:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"2_spring_web/#validaciones-en-entidades","title":"Validaciones en Entidades","text":"<p>Las validaciones se pueden aplicar a las entidades utilizando anotaciones como <code>@NotNull</code>, <code>@Size</code>, <code>@Email</code>, entre otras. Aqu\u00ed hay un ejemplo de c\u00f3mo aplicar validaciones a una entidad <code>User</code>:</p> <p><pre><code>@Entity\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n\n    @NotNull(message = \"El nombre de usuario no puede ser nulo\")\n    @Size(min = 3, max = 50, message = \"El nombre de usuario debe tener entre 3 y 50 caracteres\")\n    private String userName;\n\n    @NotNull(message = \"La contrase\u00f1a no puede ser nula\")\n    @Size(min = 6, message = \"La contrase\u00f1a debe tener al menos 6 caracteres\")\n    private String password;\n\n    @NotNull(message = \"El rol no puede ser nulo\")\n    private String role;\n\n    // Getters y setters...\n}\n</code></pre> Para este ejemplo es necesario que se incluya tambi\u00e9n en el <code>pom.xml</code> el m\u00f3dulo de Spring Data y la configuraci\u00f3n de conexi\u00f3n a BBDD (esto se explicar\u00e1 en el siguiente cap\u00edtulo): <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.mariadb.jdbc&lt;/groupId&gt;\n    &lt;artifactId&gt;mariadb-java-client&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>spring.datasource.url=jdbc:mariadb://localhost:3306/demo_db\nspring.datasource.username=mariadbuser\nspring.datasource.password=mariadbpass\nspring.datasource.driver-class-name=org.mariadb.jdbc.Driver\nspring.jpa.hibernate.ddl-auto=update\n</code></pre> Tambi\u00e9n se puede eliminar el c\u00f3digo relacionado con JPA y la BBDD para este ejemplo.</p>"},{"location":"2_spring_web/#validaciones-en-controladores","title":"Validaciones en Controladores","text":"<p>Las validaciones se pueden aplicar a los datos de entrada en los controladores utilizando la anotaci\u00f3n <code>@Valid</code>. Aqu\u00ed hay un ejemplo de c\u00f3mo validar un objeto <code>User</code> en un controlador:</p> <pre><code>@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    private static final Logger logger = LoggerFactory.getLogger(UserController.class);\n\n    @Autowired\n    private UserService userService;\n\n    @PostMapping\n    public ResponseEntity&lt;User&gt; createUser(@Valid @RequestBody User user, BindingResult result) {\n        logger.info(\"createUser endpoint llamado con datos: {}\", user);\n        if (result.hasErrors()) {\n            logger.error(\"Errores de validaci\u00f3n: {}\", result.getAllErrors());\n            return ResponseEntity.badRequest().body(null);\n        }\n        User savedUser = userService.saveUser(user);\n        return ResponseEntity.ok(savedUser);\n    }\n}\n</code></pre>"},{"location":"2_spring_web/#prueba-con-postman","title":"Prueba con Postman","text":"<p>Para probar el controlador <code>UserController</code> con Postman:</p> <ol> <li>Iniciar la aplicaci\u00f3n Spring Boot.</li> <li>Abrir Postman y crear una nueva solicitud POST.</li> <li>Configurar la URL de la solicitud a <code>http://localhost:8080/api/users</code>.</li> <li>En la pesta\u00f1a \"Headers\", a\u00f1adir el encabezado <code>Content-Type</code> con el valor <code>application/json</code>.</li> <li>En la pesta\u00f1a \"Body\", seleccionar \"raw\" y \"JSON\" y a\u00f1adir el siguiente JSON: <pre><code>{\n    \"userName\": \"testuser\",\n    \"password\": \"password123\",\n    \"role\": \"USER\"\n}\n</code></pre></li> <li>Enviar la solicitud y verificar que la respuesta sea el objeto <code>User</code> creado.</li> <li>Probar con datos inv\u00e1lidos para verificar que las validaciones funcionan correctamente, por ejemplo, con un nombre de usuario vac\u00edo: <pre><code>{\n    \"userName\": \"\",\n    \"password\": \"password123\",\n    \"role\": \"USER\"\n}\n</code></pre></li> <li>Verificar que la respuesta sea un error de validaci\u00f3n.</li> </ol>"},{"location":"2_spring_web/#validaciones-en-servicios","title":"Validaciones en Servicios","text":"<p>Las validaciones tambi\u00e9n se pueden aplicar en los servicios utilizando la anotaci\u00f3n <code>@Validated</code>. Aqu\u00ed hay un ejemplo de c\u00f3mo validar un objeto <code>User</code> en un servicio:</p> <pre><code>@Service\n@Validated\npublic class UserService {\n    private static final Logger logger = LoggerFactory.getLogger(UserService.class);\n\n    @Autowired\n    private UserRepository userRepository;\n\n    public User saveUser(@Valid User user) {\n        logger.info(\"Guardando usuario: {}\", user.getUserName());\n        return userRepository.save(user);\n    }\n}\n</code></pre>"},{"location":"2_spring_web/#prueba-del-servicio-userservice-con-postman","title":"Prueba del Servicio <code>UserService</code> con Postman","text":"<p>Para probar el servicio <code>UserService</code> con Postman y asegurar que la validaci\u00f3n se realiza en el servicio:</p> <ol> <li>Iniciar la aplicaci\u00f3n Spring Boot.</li> <li>Abrir Postman y crear una nueva solicitud POST.</li> <li>Configurar la URL de la solicitud a <code>http://localhost:8080/api/users</code>.</li> <li>En la pesta\u00f1a \"Headers\", a\u00f1adir el encabezado <code>Content-Type</code> con el valor <code>application/json</code>.</li> <li>En la pesta\u00f1a \"Body\", seleccionar \"raw\" y \"JSON\" y a\u00f1adir el siguiente JSON: <pre><code>{\n    \"userName\": \"testuser\",\n    \"password\": \"password123\",\n    \"role\": \"USER\"\n}\n</code></pre></li> <li>Enviar la solicitud y verificar que la respuesta sea el objeto <code>User</code> creado.</li> <li>Probar con datos inv\u00e1lidos para verificar que las validaciones funcionan correctamente, por ejemplo, con un nombre de usuario vac\u00edo: <pre><code>{\n    \"userName\": \"\",\n    \"password\": \"password123\",\n    \"role\": \"USER\"\n}\n</code></pre></li> <li>Verificar que la respuesta sea un error de validaci\u00f3n.</li> </ol>"},{"location":"2_spring_web/#asegurar-que-la-validacion-se-realiza-en-el-servicio","title":"Asegurar que la Validaci\u00f3n se Realiza en el Servicio","text":"<p>Para asegurar que la validaci\u00f3n se realiza en el servicio y no en el controlador, se puede modificar el controlador para que no realice la validaci\u00f3n y dejar que el servicio maneje la validaci\u00f3n:</p> <pre><code>@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    private static final Logger logger = LoggerFactory.getLogger(UserController.class);\n\n    @Autowired\n    private UserService userService;\n\n    @PostMapping\n    public ResponseEntity&lt;User&gt; createUser(@RequestBody User user) {\n        logger.info(\"createUser endpoint llamado con datos: {}\", user);\n        User savedUser = userService.saveUser(user);\n        return ResponseEntity.ok(savedUser);\n    }\n}\n</code></pre> <p>Con esta configuraci\u00f3n, la validaci\u00f3n se realizar\u00e1 \u00fanicamente en el servicio <code>UserService</code> y no en el controlador <code>UserController</code>.</p>"},{"location":"2_spring_web/#explicacion-del-codigo_2","title":"Explicaci\u00f3n del C\u00f3digo","text":"<ul> <li><code>@NotNull</code>, <code>@Size</code>, <code>@Email</code>: Anotaciones de validaci\u00f3n que se utilizan para validar los campos de una entidad.</li> <li><code>@Valid</code>: Anotaci\u00f3n que se utiliza para validar un objeto en un controlador o servicio.</li> <li><code>BindingResult</code>: Objeto que contiene los resultados de la validaci\u00f3n.</li> <li><code>@Validated</code>: Anotaci\u00f3n que se utiliza para habilitar la validaci\u00f3n en un servicio.</li> <li><code>Logger</code>: Utilizado para registrar eventos importantes y errores en la aplicaci\u00f3n.</li> </ul>"},{"location":"2_spring_web/#repositorio-de-usuarios","title":"Repositorio de Usuarios","text":"<p>Para completar el ejemplo, es necesario definir un repositorio para la entidad <code>User</code>. Aqu\u00ed hay un ejemplo de c\u00f3mo crear un repositorio utilizando Spring Data JPA:</p> <pre><code>public interface UserRepository extends JpaRepository&lt;User, Long&gt; {\n    // M\u00e9todos de consulta personalizados pueden ser a\u00f1adidos aqu\u00ed\n}\n</code></pre>"},{"location":"2_spring_web/#beneficios-de-usar-validaciones-en-spring-boot","title":"Beneficios de Usar Validaciones en Spring Boot","text":"<ul> <li>Simplicidad: Las validaciones se pueden aplicar de manera declarativa utilizando anotaciones.</li> <li>Reutilizaci\u00f3n: Las reglas de validaci\u00f3n se pueden reutilizar en diferentes capas de la aplicaci\u00f3n.</li> <li>Consistencia: Las validaciones aseguran que los datos de entrada cumplan con las reglas definidas, mejorando la consistencia de los datos.</li> </ul>"},{"location":"2_spring_web/#actividad-practica_3","title":"Actividad Pr\u00e1ctica","text":"<ul> <li>Aplicar Validaciones a una Entidad:<ul> <li>A\u00f1adir anotaciones de validaci\u00f3n a la entidad <code>User</code>.</li> <li>Crear un controlador y un servicio que utilicen las validaciones.</li> <li>Probar las validaciones utilizando una herramienta como Postman.</li> </ul> </li> </ul>"},{"location":"2_spring_web/#posibles-errores-comunes","title":"Posibles Errores Comunes","text":"<ul> <li> <p>Errores de Validaci\u00f3n:</p> <ul> <li>Soluci\u00f3n: Verificar que los datos de entrada cumplen con las reglas de validaci\u00f3n definidas en las anotaciones.</li> </ul> </li> <li> <p>Dependencias:</p> <ul> <li>Soluci\u00f3n: Asegurarse de que la dependencia <code>spring-boot-starter-validation</code> est\u00e9 incluida en el archivo <code>pom.xml</code> y ejecutar <code>mvn clean install</code> para actualizar el proyecto.</li> </ul> </li> </ul>"},{"location":"3_spring_data/","title":"Gesti\u00f3n de Datos y L\u00f3gica de Negocio con Spring Data","text":""},{"location":"3_spring_data/#capitulo-3-gestion-de-datos-y-logica-de-negocio-con-spring-data","title":"Cap\u00edtulo 3: Gesti\u00f3n de Datos y L\u00f3gica de Negocio con Spring Data","text":""},{"location":"3_spring_data/#introduccion","title":"Introducci\u00f3n","text":"<p>JPA (Java Persistence API) es una especificaci\u00f3n para el acceso, persistencia y gesti\u00f3n de datos entre aplicaciones Java y bases de datos relacionales. Hibernate es una implementaci\u00f3n de JPA. Spring Data facilita la interacci\u00f3n con bases de datos mediante la definici\u00f3n de repositorios que encapsulan las operaciones CRUD y consultas personalizadas.</p> <p>Para utilizar Spring Data JPA, es necesario incluir la siguiente dependencia en el archivo <code>pom.xml</code>:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"3_spring_data/#modelado-de-datos-con-entidades","title":"Modelado de Datos con Entidades","text":"<p>Las entidades representan las tablas de la base de datos en el c\u00f3digo Java. Cada entidad se mapea a una tabla en la base de datos y sus atributos se mapean a las columnas de la tabla.</p>"},{"location":"3_spring_data/#estrategias-de-generacion-de-claves-primarias","title":"Estrategias de Generaci\u00f3n de Claves Primarias","text":"<p>JPA proporciona varias estrategias para la generaci\u00f3n de claves primarias:</p> <ul> <li>AUTO: JPA elige autom\u00e1ticamente la estrategia de generaci\u00f3n de claves m\u00e1s adecuada para la base de datos.</li> <li>IDENTITY: Utiliza una columna de identidad en la base de datos para generar las claves primarias.</li> <li>SEQUENCE: Utiliza una secuencia en la base de datos para generar las claves primarias.</li> <li>TABLE: Utiliza una tabla especial en la base de datos para generar las claves primarias.</li> </ul> <p>Ejemplo de configuraci\u00f3n de estrategias de generaci\u00f3n de claves primarias:</p> <pre><code>@Entity\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n\n    // ...existing code...\n}\n</code></pre>"},{"location":"3_spring_data/#relaciones-entre-entidades","title":"Relaciones entre Entidades","text":"<p>JPA permite definir relaciones entre entidades utilizando anotaciones como <code>@OneToMany</code>, <code>@ManyToOne</code>, <code>@OneToOne</code> y <code>@ManyToMany</code>.</p> <p>Ejemplo de relaciones entre entidades:</p> <pre><code>@Entity\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n\n    @OneToMany(mappedBy = \"user\")\n    private List&lt;Order&gt; orders;\n\n    // ...existing code...\n}\n\n@Entity\npublic class Order {\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n\n    @ManyToOne\n    @JoinColumn(name = \"user_id\")\n    private User user;\n\n    // ...existing code...\n}\n</code></pre>"},{"location":"3_spring_data/#consultas-personalizadas-con-query","title":"Consultas Personalizadas con @Query","text":"<p>Adem\u00e1s de las operaciones CRUD est\u00e1ndar, Spring Data JPA permite definir consultas personalizadas utilizando la anotaci\u00f3n <code>@Query</code>. Aqu\u00ed hay un ejemplo de c\u00f3mo definir y utilizar consultas personalizadas en un repositorio:</p> <ul> <li> <p>Definir una Consulta Personalizada: <pre><code>@Repository\npublic interface UserRepository extends JpaRepository&lt;User, Long&gt; {\n    Optional&lt;User&gt; findByUserName(String userName);\n\n    @Query(\"SELECT u FROM User u WHERE u.role = :role\")\n    List&lt;User&gt; findUsersByRole(@Param(\"role\") String role);\n\n    @Query(\"SELECT u FROM User u WHERE u.userName LIKE %:userName%\")\n    List&lt;User&gt; findUsersByUserNameContaining(@Param(\"userName\") String userName);\n}\n</code></pre></p> <p>En este ejemplo:</p> <ul> <li><code>@Query(\"SELECT u FROM User u WHERE u.role = :role\")</code>: Define una consulta personalizada que selecciona usuarios por su rol.</li> <li><code>@Query(\"SELECT u FROM User u WHERE u.userName LIKE %:userName%\")</code>: Define una consulta personalizada que selecciona usuarios cuyo nombre de usuario contiene una cadena espec\u00edfica.</li> <li><code>@Param(\"role\")</code> y <code>@Param(\"userName\")</code>: Vinculan los par\u00e1metros de la consulta a los par\u00e1metros del m\u00e9todo.</li> </ul> </li> <li> <p>Utilizar la Consulta Personalizada en un Servicio: <pre><code>@Service\n@Validated\npublic class UserService {\n    private static final Logger logger = LoggerFactory.getLogger(UserService.class);\n\n    @Autowired\n    private UserRepository userRepository;\n\n    public User saveUser(@Valid User user) {\n        logger.info(\"Guardando usuario: {}\", user.getUserName());\n        return userRepository.save(user);\n    }\n\n    public List&lt;User&gt; getUsersByRole(String role) {\n        logger.info(\"Buscando usuarios con rol: {}\", role);\n        return userRepository.findUsersByRole(role);\n    }\n\n    public List&lt;User&gt; getUsersByUserNameContaining(String userName) {\n        logger.info(\"Buscando usuarios cuyo nombre contiene: {}\", userName);\n        return userRepository.findUsersByUserNameContaining(userName);\n    }\n}\n</code></pre></p> <p>En este ejemplo:</p> <ul> <li><code>getUsersByRole(String role)</code>: M\u00e9todo del servicio que utiliza la consulta personalizada para obtener usuarios por su rol.</li> <li><code>getUsersByUserNameContaining(String userName)</code>: M\u00e9todo del servicio que utiliza la consulta personalizada para obtener usuarios cuyo nombre de usuario contiene una cadena espec\u00edfica.</li> <li><code>Logger</code>: Utilizado para registrar eventos importantes y errores en la aplicaci\u00f3n.</li> </ul> </li> </ul>"},{"location":"3_spring_data/#consultas-nativas-y-criteria-api","title":"Consultas Nativas y Criteria API","text":"<p>Spring Data JPA permite definir consultas nativas y utilizar Criteria API para consultas din\u00e1micas.</p> <ul> <li> <p>Consultas Nativas: <pre><code>@Repository\npublic interface UserRepository extends JpaRepository&lt;User, Long&gt; {\n    @Query(value = \"SELECT * FROM users WHERE role = ?1\", nativeQuery = true)\n    List&lt;User&gt; findUsersByRoleNative(String role);\n}\n</code></pre></p> </li> <li> <p>Criteria API: <pre><code>@Service\npublic class UserService {\n    @PersistenceContext\n    private EntityManager entityManager;\n\n    public List&lt;User&gt; findUsersByCriteria(String role) {\n        CriteriaBuilder cb = entityManager.getCriteriaBuilder();\n        CriteriaQuery&lt;User&gt; query = cb.createQuery(User.class);\n        Root&lt;User&gt; user = query.from(User.class);\n        query.select(user).where(cb.equal(user.get(\"role\"), role));\n        return entityManager.createQuery(query).getResultList();\n    }\n}\n</code></pre></p> </li> </ul>"},{"location":"3_spring_data/#explicacion-del-codigo","title":"Explicaci\u00f3n del C\u00f3digo","text":"<ul> <li><code>@Entity</code>: Indica que la clase es una entidad JPA.</li> <li><code>@GeneratedValue(strategy = GenerationType.AUTO)</code>: Configura la estrategia de generaci\u00f3n de claves primarias.</li> <li><code>@OneToMany</code>, <code>@ManyToOne</code>: Define relaciones entre entidades.</li> <li><code>@Query</code>: Define consultas personalizadas.</li> <li><code>CriteriaBuilder</code>, <code>CriteriaQuery</code>: Utilizados para crear consultas din\u00e1micas con Criteria API.</li> </ul>"},{"location":"3_spring_data/#que-es-criteria-api","title":"\u00bfQu\u00e9 es Criteria API?","text":"<p>Criteria API es una funcionalidad de JPA que permite construir consultas de manera program\u00e1tica utilizando una API de tipo seguro. Esto significa que las consultas se construyen utilizando m\u00e9todos de Java en lugar de cadenas de texto, lo que proporciona varias ventajas:</p> <ul> <li>Tipo Seguro: Las consultas se construyen utilizando clases y m\u00e9todos de Java, lo que permite que el compilador verifique los tipos y reduzca los errores en tiempo de compilaci\u00f3n.</li> <li>Consultas Din\u00e1micas: Criteria API permite construir consultas din\u00e1micas de manera program\u00e1tica, lo que es \u00fatil cuando las condiciones de la consulta no se conocen de antemano.</li> <li>Mantenimiento: Las consultas construidas con Criteria API son m\u00e1s f\u00e1ciles de mantener y refactorizar, ya que est\u00e1n escritas en Java y no en cadenas de texto.</li> </ul>"},{"location":"3_spring_data/#funcionalidades-de-criteria-api","title":"Funcionalidades de Criteria API","text":"<ul> <li>Construcci\u00f3n de Consultas: Criteria API permite construir consultas SELECT, UPDATE y DELETE de manera program\u00e1tica.</li> <li>Condiciones Din\u00e1micas: Permite agregar condiciones din\u00e1micas a las consultas utilizando m\u00e9todos como <code>where</code>, <code>and</code>, <code>or</code>, etc.</li> <li>Ordenaci\u00f3n y Agrupaci\u00f3n: Permite agregar ordenaci\u00f3n y agrupaci\u00f3n a las consultas utilizando m\u00e9todos como <code>orderBy</code> y <code>groupBy</code>.</li> <li>Subconsultas: Permite construir subconsultas de manera program\u00e1tica.</li> <li>Uniones: Permite realizar uniones entre entidades utilizando m\u00e9todos como <code>join</code>.</li> </ul> <p>Ejemplo de una consulta din\u00e1mica utilizando Criteria API:</p> <pre><code>@Service\npublic class UserService {\n    @PersistenceContext\n    private EntityManager entityManager;\n\n    public List&lt;User&gt; findUsersByCriteria(String role, String userName) {\n        CriteriaBuilder cb = entityManager.getCriteriaBuilder();\n        CriteriaQuery&lt;User&gt; query = cb.createQuery(User.class);\n        Root&lt;User&gt; user = query.from(User.class);\n\n        List&lt;Predicate&gt; predicates = new ArrayList&lt;&gt;();\n        if (role != null) {\n            predicates.add(cb.equal(user.get(\"role\"), role));\n        }\n        if (userName != null) {\n            predicates.add(cb.like(user.get(\"userName\"), \"%\" + userName + \"%\"));\n        }\n\n        query.select(user).where(predicates.toArray(new Predicate[0]));\n        return entityManager.createQuery(query).getResultList();\n    }\n}\n</code></pre> <p>En este ejemplo, se construye una consulta din\u00e1mica que busca usuarios por rol y nombre de usuario. Las condiciones se agregan a la consulta de manera program\u00e1tica utilizando <code>CriteriaBuilder</code> y <code>Predicate</code>.</p>"},{"location":"3_spring_data/#beneficios-de-usar-criteria-api","title":"Beneficios de Usar Criteria API","text":"<ul> <li>Simplicidad: Permite construir consultas complejas de manera sencilla y program\u00e1tica.</li> <li>Flexibilidad: Permite agregar condiciones din\u00e1micas a las consultas.</li> <li>Mantenimiento: Las consultas son m\u00e1s f\u00e1ciles de mantener y refactorizar.</li> </ul>"},{"location":"3_spring_data/#actividad-practica","title":"Actividad Pr\u00e1ctica","text":"<ul> <li>Crear Consultas Din\u00e1micas con Criteria API:<ul> <li>Definir consultas din\u00e1micas en el servicio <code>UserService</code>.</li> <li>Probar las consultas din\u00e1micas utilizando una herramienta como Postman.</li> </ul> </li> </ul>"},{"location":"3_spring_data/#beneficios-de-usar-spring-data-jpa","title":"Beneficios de Usar Spring Data JPA","text":"<ul> <li>Simplicidad: Spring Data JPA simplifica la interacci\u00f3n con bases de datos mediante la definici\u00f3n de repositorios y consultas personalizadas.</li> <li>Flexibilidad: Permite definir consultas personalizadas utilizando JPQL, consultas nativas y Criteria API.</li> </ul>"},{"location":"3_spring_data/#actividad-practica_1","title":"Actividad Pr\u00e1ctica","text":"<ul> <li>Definir Consultas Personalizadas:<ul> <li>A\u00f1adir consultas personalizadas en el repositorio <code>UserRepository</code>.</li> <li>Utilizar las consultas personalizadas en el servicio <code>UserService</code>.</li> <li>Probar las consultas personalizadas utilizando una herramienta como Postman.</li> </ul> </li> </ul>"},{"location":"3_spring_data/#logica-de-negocio-en-servicios","title":"L\u00f3gica de Negocio en Servicios","text":"<p>Los servicios contienen la l\u00f3gica de negocio de la aplicaci\u00f3n y se implementan utilizando la anotaci\u00f3n <code>@Service</code>. Los servicios interact\u00faan con los repositorios para realizar operaciones en la base de datos.</p>"},{"location":"3_spring_data/#actividad-practica-integrada","title":"Actividad Pr\u00e1ctica Integrada","text":""},{"location":"3_spring_data/#configuracion-de-la-base-de-datos-local","title":"Configuraci\u00f3n de la Base de Datos Local","text":"<p>Antes de probar el repositorio, es necesario configurar una base de datos local. A continuaci\u00f3n, se muestran los pasos para configurar una base de datos MariaDB utilizando Docker:</p> <ul> <li> <p>Instalar Docker:</p> <ul> <li>Seguir las instrucciones de instalaci\u00f3n en Docker Downloads.</li> </ul> </li> <li> <p>Configurar y ejecutar el contenedor MariaDB:</p> <ul> <li>Clonar el repositorio que contiene el archivo <code>docker-compose.yml</code>: <pre><code>git clone https://github.com/jibanezmico/DockerUtils.git\ncd DockerUtils/MariaDB\n</code></pre></li> </ul> </li> <li> <p>Ejecutar el contenedor: <pre><code>docker-compose up -d\n</code></pre></p> </li> <li> <p>Verificar que el contenedor est\u00e1 en ejecuci\u00f3n:</p> <ul> <li>Usar el comando <code>docker ps</code> para asegurarse de que el contenedor MariaDB est\u00e1 en ejecuci\u00f3n.</li> </ul> </li> <li> <p>Configurar el archivo <code>application.properties</code>: <pre><code>spring.datasource.url=jdbc:mariadb://localhost:3306/demo_db\nspring.datasource.username=mariadbuser\nspring.datasource.password=mariadbpass\nspring.datasource.driver-class-name=org.mariadb.jdbc.Driver\nspring.jpa.hibernate.ddl-auto=update\n</code></pre></p> </li> <li> <p>Probar la conexi\u00f3n:</p> <ul> <li>Ejecutar la aplicaci\u00f3n Spring Boot y verificar que se conecta correctamente a la base de datos.</li> </ul> </li> <li> <p>Crear la entidad <code>User</code>: <pre><code>@Entity\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n\n    @NotNull(message = \"El nombre de usuario no puede ser nulo\")\n    @Size(min = 3, max = 50, message = \"El nombre de usuario debe tener entre 3 y 50 caracteres\")\n    private String userName;\n\n    @NotNull(message = \"La contrase\u00f1a no puede ser nula\")\n    @Size(min = 6, message = \"La contrase\u00f1a debe tener al menos 6 caracteres\")\n    private String password;\n\n    @NotNull(message = \"El rol no puede ser nulo\")\n    private String role;\n\n    // Getters y setters...\n}\n</code></pre>    Esta clase <code>User</code> representa una entidad en la base de datos. La anotaci\u00f3n <code>@Entity</code> indica que esta clase es una entidad JPA. La anotaci\u00f3n <code>@Id</code> se utiliza para especificar el identificador de la entidad, y <code>@GeneratedValue</code> se utiliza para generar autom\u00e1ticamente el valor del identificador.</p> </li> <li> <p>Crear el repositorio <code>UserRepository</code>: <pre><code>@Repository\npublic interface UserRepository extends JpaRepository&lt;User, Long&gt; {\n    Optional&lt;User&gt; findByUserName(String userName);\n\n    @Query(\"SELECT u FROM User u WHERE u.role = :role\")\n    List&lt;User&gt; findUsersByRole(@Param(\"role\") String role);\n\n    @Query(\"SELECT u FROM User u WHERE u.userName LIKE %:userName%\")\n    List&lt;User&gt; findUsersByUserNameContaining(@Param(\"userName\") String userName);\n}\n</code></pre>    Esta interfaz <code>UserRepository</code> extiende <code>JpaRepository</code>, lo que proporciona m\u00e9todos CRUD est\u00e1ndar para la entidad <code>User</code>. Adem\u00e1s, se define un m\u00e9todo personalizado <code>findByUserName</code> para buscar usuarios por nombre de usuario y consultas personalizadas <code>findUsersByRole</code> y <code>findUsersByUserNameContaining</code> para buscar usuarios por rol y por nombre de usuario, respectivamente.</p> </li> <li> <p>Configurar el archivo <code>application.properties</code>: <pre><code>spring.datasource.url=jdbc:mariadb://localhost:3306/demo_db\nspring.datasource.username=mariadbuser\nspring.datasource.password=mariadbpass\nspring.datasource.driver-class-name=org.mariadb.jdbc.Driver\nspring.jpa.hibernate.ddl-auto=update\n</code></pre>    Este archivo <code>application.properties</code> contiene la configuraci\u00f3n de la base de datos. Se especifica la URL de la base de datos, el nombre de usuario, la contrase\u00f1a y el controlador JDBC. La propiedad <code>spring.jpa.hibernate.ddl-auto=update</code> indica que Hibernate debe actualizar el esquema de la base de datos en funci\u00f3n de las entidades definidas.</p> </li> <li> <p>Crear el servicio <code>UserService</code>: <pre><code>@Service\n@Validated\npublic class UserService implements UserDetailsService {\n    private static final Logger logger = LoggerFactory.getLogger(UserService.class);\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        logger.info(\"Cargando usuario por nombre de usuario: {}\", username);\n        User user = userRepository.findByUserName(username)\n            .orElseThrow(() -&gt; new UsernameNotFoundException(\"Usuario no encontrado\"));\n        logger.info(\"Usuario encontrado: {}\", username);\n        return new org.springframework.security.core.userdetails.User(\n            user.getUserName(),\n            user.getPassword(),\n            Collections.singleton(new SimpleGrantedAuthority(\"ROLE_\" + user.getRole()))\n        );\n    }\n\n    public List&lt;User&gt; getAllUsers() {\n        logger.info(\"Obteniendo todos los usuarios\");\n        return userRepository.findAll();\n    }\n\n    public User saveUser(@Valid User user) {\n        logger.info(\"Guardando usuario: {}\", user.getUserName());\n        logger.debug(\"Datos del usuario: {}\", user);\n        return userRepository.save(user);\n    }\n\n    public Optional&lt;User&gt; getByUserName(String userName) {\n        logger.info(\"Buscando usuario por nombre de usuario: {}\", userName);\n        return userRepository.findByUserName(userName);\n    }\n\n    public List&lt;User&gt; getUsersByRole(String role) {\n        logger.info(\"Buscando usuarios con rol: {}\", role);\n        return userRepository.findUsersByRole(role);\n    }\n\n    public List&lt;User&gt; getUsersByUserNameContaining(String userName) {\n        logger.info(\"Buscando usuarios cuyo nombre contiene: {}\", userName);\n        return userRepository.findUsersByUserNameContaining(userName);\n    }\n}\n</code></pre></p> </li> </ul> <p>Esta clase <code>UserService</code> implementa <code>UserDetailsService</code> para proporcionar detalles de usuario a Spring Security. El m\u00e9todo <code>loadUserByUsername</code> carga un usuario por nombre de usuario y lanza una excepci\u00f3n si el usuario no se encuentra. Adem\u00e1s, se proporcionan m\u00e9todos para obtener todos los usuarios, guardar un usuario, buscar un usuario por nombre de usuario, buscar usuarios por rol y buscar usuarios cuyo nombre de usuario contiene una cadena espec\u00edfica. Se utiliza un Logger para registrar eventos importantes y se aplican validaciones a la entidad <code>User</code>.</p>"},{"location":"3_spring_data/#material-avanzado","title":"Material Avanzado","text":""},{"location":"3_spring_data/#auditoria-en-spring-data-jpa","title":"Auditor\u00eda en Spring Data JPA","text":"<p>Spring Data JPA proporciona soporte para auditor\u00eda de entidades, permitiendo rastrear cambios en los datos. Para habilitar la auditor\u00eda, se deben seguir los siguientes pasos:</p> <ul> <li>Habilitar la Auditor\u00eda:<ul> <li>A\u00f1adir la anotaci\u00f3n <code>@EnableJpaAuditing</code> en una clase de configuraci\u00f3n.</li> </ul> </li> </ul> <pre><code>@Configuration\n@EnableJpaAuditing\npublic class JpaConfig {\n    // ...existing code...\n}\n</code></pre> <ul> <li>Configurar las Entidades para Auditor\u00eda:<ul> <li>A\u00f1adir las anotaciones <code>@CreatedDate</code>, <code>@LastModifiedDate</code>, <code>@CreatedBy</code> y <code>@LastModifiedBy</code> en las entidades.</li> </ul> </li> </ul> <pre><code>@Entity\n@EntityListeners(AuditingEntityListener.class)\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n\n    @CreatedDate\n    private LocalDateTime createdDate;\n\n    @LastModifiedDate\n    private LocalDateTime lastModifiedDate;\n\n    @CreatedBy\n    private String createdBy;\n\n    @LastModifiedBy\n    private String lastModifiedBy;\n\n    // ...existing code...\n}\n</code></pre>"},{"location":"3_spring_data/#uso-de-specification-para-consultas-dinamicas","title":"Uso de Specification para Consultas Din\u00e1micas","text":"<p>Spring Data JPA proporciona la interfaz <code>Specification</code> para crear consultas din\u00e1micas.</p> <ul> <li> <p>Definir una Especificaci\u00f3n: <pre><code>public class UserSpecification {\n    public static Specification&lt;User&gt; hasRole(String role) {\n        return (root, query, cb) -&gt; cb.equal(root.get(\"role\"), role);\n    }\n\n    public static Specification&lt;User&gt; userNameContains(String userName) {\n        return (root, query, cb) -&gt; cb.like(root.get(\"userName\"), \"%\" + userName + \"%\");\n    }\n}\n</code></pre></p> </li> <li> <p>Utilizar la Especificaci\u00f3n en un Repositorio: <pre><code>@Repository\npublic interface UserRepository extends JpaRepository&lt;User, Long&gt;, JpaSpecificationExecutor&lt;User&gt; {\n}\n</code></pre></p> </li> <li> <p>Utilizar la Especificaci\u00f3n en un Servicio: <pre><code>@Service\npublic class UserService {\n    @Autowired\n    private UserRepository userRepository;\n\n    public List&lt;User&gt; findUsersByRoleAndUserName(String role, String userName) {\n        return userRepository.findAll(Specification.where(UserSpecification.hasRole(role))\n                .and(UserSpecification.userNameContains(userName)));\n    }\n}\n</code></pre></p> </li> </ul>"},{"location":"3_spring_data/#explicacion-del-codigo_1","title":"Explicaci\u00f3n del C\u00f3digo","text":"<ul> <li><code>@EnableJpaAuditing</code>: Habilita la auditor\u00eda en Spring Data JPA.</li> <li><code>@CreatedDate</code>, <code>@LastModifiedDate</code>, <code>@CreatedBy</code>, <code>@LastModifiedBy</code>: Anotaciones de auditor\u00eda.</li> <li><code>Specification</code>: Interfaz utilizada para crear consultas din\u00e1micas.</li> </ul>"},{"location":"3_spring_data/#beneficios-de-usar-auditoria-y-specification","title":"Beneficios de Usar Auditor\u00eda y Specification","text":"<ul> <li>Auditor\u00eda: Proporciona soporte para auditor\u00eda de entidades, permitiendo rastrear cambios en los datos.</li> <li>Consultas Din\u00e1micas: Permite crear consultas din\u00e1micas utilizando la interfaz <code>Specification</code>.</li> </ul>"},{"location":"3_spring_data/#actividad-practica_2","title":"Actividad Pr\u00e1ctica","text":"<ul> <li> <p>Configurar la Auditor\u00eda en una Entidad:</p> <ul> <li>A\u00f1adir las anotaciones de auditor\u00eda a la entidad <code>User</code>.</li> <li>Habilitar la auditor\u00eda en una clase de configuraci\u00f3n.</li> <li>Probar la auditor\u00eda creando y modificando entidades <code>User</code>.</li> </ul> </li> <li> <p>Crear Consultas Din\u00e1micas con Specification:</p> <ul> <li>Definir especificaciones en la clase <code>UserSpecification</code>.</li> <li>Utilizar las especificaciones en el servicio <code>UserService</code>.</li> <li>Probar las consultas din\u00e1micas utilizando una herramienta como Postman.</li> </ul> </li> </ul>"},{"location":"4_spring_security/","title":"Configuraci\u00f3n de Seguridad en Spring Security","text":"<p>En esta secci\u00f3n se describe la configuraci\u00f3n de seguridad de la aplicaci\u00f3n mediante Spring Security, incluyendo la gesti\u00f3n de autenticaci\u00f3n y autorizaci\u00f3n basada en tokens JWT.</p> <p>Para ello debemos a\u00f1adir en nuestro pom.xml las siguientes dependencias:</p> <pre><code>        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;\n            &lt;artifactId&gt;jjwt&lt;/artifactId&gt;\n            &lt;version&gt;0.9.1&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>"},{"location":"4_spring_security/#configuracion-de-spring-security","title":"Configuraci\u00f3n de Spring Security","text":"<p>La clase <code>SecurityConfig</code> define las reglas de seguridad de la aplicaci\u00f3n, gestionando la autenticaci\u00f3n y autorizaci\u00f3n de las rutas.</p> <pre><code>/**\n * Clase de configuraci\u00f3n de seguridad. Se definen las reglas de seguridad.\n * SecurityConfig\n */\n@Configuration\npublic class SecurityConfig {\n\n    // Inyecci\u00f3n de dependencias para manejar errores de autenticaci\u00f3n\n    @Autowired\n    private JwtEntryPoint jwtEntryPoint;\n\n    // Definici\u00f3n del filtro de autenticaci\u00f3n JWT como un bean\n    @Bean\n    public JwtAuthenticationFilter jwtAuthenticationFilter() {\n        return new JwtAuthenticationFilter();\n    }\n\n    /**\n     * Configuraci\u00f3n de la cadena de filtros de seguridad.\n     *\n     * @param http Objeto HttpSecurity para configurar la seguridad HTTP.\n     * @return SecurityFilterChain configurado.\n     * @throws Exception en caso de error en la configuraci\u00f3n de seguridad.\n     */\n    @Bean\n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n        http\n            // Desactivar CSRF para simplificar la configuraci\u00f3n\n            .csrf(csrf -&gt; csrf.disable())\n            // Configuraci\u00f3n de las reglas de autorizaci\u00f3n\n            .authorizeHttpRequests(auth -&gt; auth\n                // Permitir acceso a rutas p\u00fablicas\n                .requestMatchers(\"/public/**\").permitAll()\n                // Permitir acceso a rutas de autenticaci\u00f3n\n                .requestMatchers(\"/auth/**\").permitAll()\n                // Requerir autenticaci\u00f3n para cualquier otra ruta\n                .anyRequest().authenticated()\n            )\n            // Manejar errores de autenticaci\u00f3n con JwtEntryPoint\n            .exceptionHandling(exception -&gt; exception\n                .authenticationEntryPoint(jwtEntryPoint)\n            )\n            // A\u00f1adir el filtro de autenticaci\u00f3n JWT antes del filtro de autenticaci\u00f3n de usuario y contrase\u00f1a\n            .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)\n            // Configuraci\u00f3n de la p\u00e1gina de inicio de sesi\u00f3n personalizada (opcional)\n            .formLogin(form -&gt; form\n                .loginPage(\"/login\")\n                .permitAll()\n            );\n        return http.build();\n    }\n\n    /**\n     * Definici\u00f3n del bean AuthenticationManager para manejar la autenticaci\u00f3n.\n     *\n     * @param authenticationConfiguration Objeto AuthenticationConfiguration para configurar el AuthenticationManager.\n     * @return AuthenticationManager configurado.\n     * @throws Exception en caso de error en la configuraci\u00f3n del AuthenticationManager.\n     */\n    @Bean\n    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {\n        return authenticationConfiguration.getAuthenticationManager();\n    }\n\n    /**\n     * Definici\u00f3n del bean PasswordEncoder para codificar las contrase\u00f1as.\n     *\n     * @return PasswordEncoder configurado.\n     */\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n}\n</code></pre>"},{"location":"4_spring_security/#explicacion","title":"Explicaci\u00f3n:","text":"<ul> <li>Filtro de autenticaci\u00f3n JWT: Se encarga de interceptar y validar tokens en cada solicitud.</li> <li>Gesti\u00f3n de credenciales: Extrae el token JWT de la cabecera de autorizaci\u00f3n y valida su autenticidad.</li> <li>Autenticaci\u00f3n en el contexto de seguridad: Establece la autenticaci\u00f3n si el token es v\u00e1lido.</li> </ul>"},{"location":"4_spring_security/#jwtauthenticationfilter","title":"JwtAuthenticationFilter","text":"<p>La clase <code>JwtAuthenticationFilter</code> es un filtro de Spring Security que intercepta las solicitudes HTTP para validar tokens JWT. Su funci\u00f3n es extraer el token de la cabecera de autorizaci\u00f3n, validarlo mediante JwtProvider y, si es correcto, establecer la autenticaci\u00f3n del usuario en el contexto de seguridad de Spring. Se ejecuta antes del filtro de autenticaci\u00f3n est\u00e1ndar, garantizando que solo las solicitudes autenticadas accedan a los recursos protegidos.</p> <pre><code>/**\n * Filtro de autenticaci\u00f3n JWT que se ejecuta una vez por solicitud.\n */\npublic class JwtAuthenticationFilter extends OncePerRequestFilter {\n\n    @Autowired\n    private JwtProvider jwtProvider;\n    @Autowired\n    private UserDetailsService userDetailsService;\n\n    /**\n     * M\u00e9todo que filtra cada solicitud para autenticar el usuario basado en el token JWT.\n     *\n     * @param request     El objeto HttpServletRequest.\n     * @param response    El objeto HttpServletResponse.\n     * @param filterChain La cadena de filtros.\n     * @throws ServletException en caso de error en el servlet.\n     * @throws IOException      en caso de error de E/S.\n     */\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n            throws ServletException, IOException {\n        // Obtener el token JWT de la solicitud\n        String jwt = getJwtFromRequest(request);\n\n        // Validar el token JWT\n        if (jwt != null &amp;&amp; jwtProvider.validateToken(jwt)) {\n            // Obtener el nombre de usuario del token JWT\n            String username = jwtProvider.extractUsername(jwt);\n\n            // Cargar los detalles del usuario\n            UserDetails userDetails = userDetailsService.loadUserByUsername(username);\n\n            // Crear la autenticaci\u00f3n basada en el token JWT\n            if (userDetails != null) {\n                UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());\n                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));\n\n                // Establecer la autenticaci\u00f3n en el contexto de seguridad\n                SecurityContextHolder.getContext().setAuthentication(authentication);\n            }\n        }\n\n        // Continuar con la cadena de filtros\n        filterChain.doFilter(request, response);\n    }\n\n    /**\n     * Obtiene el token JWT de la solicitud.\n     *\n     * @param request El objeto HttpServletRequest.\n     * @return El token JWT si est\u00e1 presente, de lo contrario null.\n     */\n    private String getJwtFromRequest(HttpServletRequest request) {\n        String bearerToken = request.getHeader(\"Authorization\");\n        if (bearerToken != null &amp;&amp; bearerToken.startsWith(\"Bearer \")) {\n            return bearerToken.substring(7);\n        }\n        return null;\n    }\n}\n</code></pre>"},{"location":"4_spring_security/#explicacion_1","title":"Explicaci\u00f3n:","text":"<ul> <li>Extracci\u00f3n del token JWT: Se obtiene el token de la cabecera de autorizaci\u00f3n.</li> <li>Validaci\u00f3n del token: Se verifica la autenticidad del token recibido.</li> <li>Establecimiento de la autenticaci\u00f3n: Si el token es v\u00e1lido, se autentica al usuario en el contexto de seguridad de Spring.</li> </ul>"},{"location":"4_spring_security/#punto-de-entrada-de-autenticacion","title":"Punto de Entrada de Autenticaci\u00f3n","text":"<p>La clase <code>JwtEntryPoint</code> maneja los errores de autenticaci\u00f3n y env\u00eda respuestas adecuadas cuando el usuario no est\u00e1 autorizado.</p> <pre><code>/**\n * Punto de entrada de autenticaci\u00f3n JWT que se ejecuta cuando se produce un error de autenticaci\u00f3n.\n */\n@Component\npublic class JwtEntryPoint implements AuthenticationEntryPoint {\n\n    /**\n     * M\u00e9todo que se ejecuta cuando se produce un error de autenticaci\u00f3n.\n     *\n     * @param request       El objeto HttpServletRequest.\n     * @param response      El objeto HttpServletResponse.\n     * @param authException La excepci\u00f3n de autenticaci\u00f3n.\n     * @throws IOException      en caso de error de E/S.\n     * @throws ServletException en caso de error en el servlet.\n     */\n    @Override\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\n        // Obtener la URL completa de la solicitud\n        String urlRequest = SecurityUtils.getFullURL(request);\n        // Obtener la IP del cliente\n        String ip = SecurityUtils.getClientIP(request);\n\n        // Manejar diferentes tipos de excepciones de autenticaci\u00f3n\n        if (authException instanceof BadCredentialsException || authException instanceof InternalAuthenticationServiceException) {\n            // El token no es v\u00e1lido. Puede a\u00f1adirse un control para bloquear la IP.\n            System.err.println(\"Error de autenticaci\u00f3n. IP: \" + ip + \". Request URL: \" + urlRequest);\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Credenciales err\u00f3neas\");\n        } else {\n            // No autorizado\n            System.err.println(\"Error de petici\u00f3n. IP: \" + ip + \". Request URL: \" + urlRequest);\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"No autorizado\");\n        }\n    }\n}\n</code></pre>"},{"location":"4_spring_security/#explicacion_2","title":"Explicaci\u00f3n:","text":"<ul> <li>Gesti\u00f3n de errores: Se encarga de devolver un error 401 cuando no se proporciona una autenticaci\u00f3n v\u00e1lida.</li> <li>Mensajes personalizados: Devuelve mensajes espec\u00edficos dependiendo del tipo de error.</li> </ul>"},{"location":"4_spring_security/#proveedor-de-tokens-jwt","title":"Proveedor de Tokens JWT","text":"<p>La clase <code>JwtProvider</code> se encarga de la generaci\u00f3n y validaci\u00f3n de tokens JWT para autenticar usuarios.</p> <pre><code>/**\n * Proveedor de JWT que maneja la generaci\u00f3n y validaci\u00f3n de tokens JWT.\n */\n@Component\npublic class JwtProvider {\n\n    // Clave secreta para firmar el token JWT\n    @Value(\"${jwt.secret}\")\n    private String secret;\n    @Value(\"${jwt.expiration}\")\n    private int expiration;\n\n    /**\n     * Genera un token JWT basado en la autenticaci\u00f3n.\n     *\n     * @param authentication La autenticaci\u00f3n del usuario.\n     * @return El token JWT generado.\n     */\n    public String generateToken(Authentication authentication) {\n        UserDetails userDetails = (UserDetails) authentication.getPrincipal();\n        return Jwts.builder()\n                .setSubject(userDetails.getUsername())\n                .setIssuedAt(new Date())\n                .setExpiration(new Date(System.currentTimeMillis() + expiration * 1000)) // 10 horas de expiraci\u00f3n\n                .signWith(SignatureAlgorithm.HS256, secret)\n                .compact();\n    }\n\n    /**\n     * Extrae el nombre de usuario del token JWT.\n     *\n     * @param token El token JWT.\n     * @return El nombre de usuario extra\u00eddo del token.\n     */\n    public String extractUsername(String token) {\n        return extractClaim(token, Claims::getSubject);\n    }\n\n    /**\n     * Extrae la fecha de expiraci\u00f3n del token JWT.\n     *\n     * @param token El token JWT.\n     * @return La fecha de expiraci\u00f3n del token.\n     */\n    public Date extractExpiration(String token) {\n        return extractClaim(token, Claims::getExpiration);\n    }\n\n    /**\n     * Extrae un reclamo espec\u00edfico del token JWT.\n     *\n     * @param token El token JWT.\n     * @param claimsResolver La funci\u00f3n para resolver el reclamo.\n     * @param &lt;T&gt; El tipo del reclamo.\n     * @return El reclamo extra\u00eddo.\n     */\n    public &lt;T&gt; T extractClaim(String token, Function&lt;Claims, T&gt; claimsResolver) {\n        final Claims claims = extractAllClaims(token);\n        return claimsResolver.apply(claims);\n    }\n\n    /**\n     * Extrae todos los reclamos del token JWT.\n     *\n     * @param token El token JWT.\n     * @return Los reclamos extra\u00eddos del token.\n     */\n    private Claims extractAllClaims(String token) {\n        return Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody();\n    }\n\n    /**\n     * Verifica si el token JWT ha expirado.\n     *\n     * @param token El token JWT.\n     * @return true si el token ha expirado, false en caso contrario.\n     */\n    private Boolean isTokenExpired(String token) {\n        return extractExpiration(token).before(new Date());\n    }\n\n    /**\n     * Valida el token JWT.\n     *\n     * @param token El token JWT.\n     * @return true si el token es v\u00e1lido, false en caso contrario.\n     */\n    public boolean validateToken(String token) {\n        try {\n            Jwts.parser().setSigningKey(secret).parseClaimsJws(token);\n            return true;\n        } catch (MalformedJwtException e) {\n            System.err.println(\"token mal formado\");\n        } catch (UnsupportedJwtException e) {\n            System.err.println(\"token no soportado\");\n        } catch (ExpiredJwtException e) {\n            System.err.println(\"token expirado\");\n        } catch (IllegalArgumentException e) {\n            System.err.println(\"token vac\u00edo\");\n        }\n        return false;\n    }\n\n    /**\n     * Valida el token JWT contra los detalles del usuario.\n     *\n     * @param token El token JWT.\n     * @param userDetails Los detalles del usuario.\n     * @return true si el token es v\u00e1lido y coincide con los detalles del usuario, false en caso contrario.\n     */\n    public Boolean validateToken(String token, UserDetails userDetails) {\n        final String username = extractUsername(token);\n        return (username.equals(userDetails.getUsername()) &amp;&amp; !isTokenExpired(token));\n    }\n}\n</code></pre>"},{"location":"4_spring_security/#explicacion_3","title":"Explicaci\u00f3n:","text":"<ul> <li>Generaci\u00f3n de tokens: Crea tokens JWT v\u00e1lidos con informaci\u00f3n del usuario autenticado.</li> <li>Validaci\u00f3n de tokens: Verifica la autenticidad de un token recibido.</li> <li>Extracci\u00f3n de usuario: Obtiene el nombre de usuario a partir del token JWT.</li> </ul>"},{"location":"4_spring_security/#controlador-de-usuarios","title":"Controlador de Usuarios","text":"<p>La clase <code>UserController</code> proporciona los endpoints necesarios para la gesti\u00f3n de usuarios.</p> <pre><code>/**\n * Controlador que maneja las solicitudes relacionadas con los usuarios.\n */\n@RestController\n@RequestMapping(\"/user\")\npublic class UserController {\n\n    @Autowired\n    private UserService userService;\n\n    /**\n     * Endpoint para obtener la lista de todos los usuarios.\n     *\n     * @return ResponseEntity con la lista de usuarios y el estado HTTP OK.\n     */\n    @GetMapping(\"/list\")\n    public ResponseEntity&lt;List&lt;User&gt;&gt; getAllUsers() {\n        // Obtener la lista de todos los usuarios\n        List&lt;User&gt; usuarios = userService.getAllUsers();\n        // Devolver la lista de usuarios con el estado HTTP OK\n        return ResponseEntity\n                .status(HttpStatus.OK)\n                .body(usuarios);\n    }\n}\n</code></pre>"},{"location":"4_spring_security/#explicacion_4","title":"Explicaci\u00f3n:","text":"<ul> <li>Operaciones CRUD: Permite la obtenci\u00f3n de usuarios a trav\u00e9s de su ID.</li> <li>Uso de <code>UserService</code>: Delegaci\u00f3n de la l\u00f3gica de negocio al servicio correspondiente.</li> </ul>"},{"location":"4_spring_security/#servicio-de-usuarios","title":"Servicio de Usuarios","text":"<p>La clase <code>UserService</code> implementa la l\u00f3gica de negocio relacionada con los usuarios.</p> <pre><code>/**\n * Servicio para manejar las operaciones relacionadas con los usuarios.\n */\n@Service\npublic class UserService implements UserDetailsService {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    /**\n     * Carga un usuario por su nombre de usuario.\n     *\n     * @param username El nombre de usuario.\n     * @return Los detalles del usuario.\n     * @throws UsernameNotFoundException si el usuario no se encuentra.\n     */\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        // Buscar el usuario por nombre de usuario en el repositorio\n        User user = userRepository.findByUserName(username)\n            .orElseThrow(() -&gt; new UsernameNotFoundException(\"Usuario no encontrado\"));\n\n        // Crear y devolver un objeto UserDetails con el nombre de usuario, contrase\u00f1a y rol del usuario\n        return new org.springframework.security.core.userdetails.User(\n            user.getUserName(),\n            user.getPassword(),\n            Collections.singleton(new SimpleGrantedAuthority(\"ROLE_\" + user.getRole()))\n        );\n    }\n\n    /**\n     * Obtiene todos los usuarios.\n     *\n     * @return Una lista de todos los usuarios.\n     */\n    public List&lt;User&gt; getAllUsers() {\n        return userRepository.findAll();\n    }\n\n    /**\n     * Guarda un usuario.\n     *\n     * @param user El usuario a guardar.\n     * @return El usuario guardado.\n     */\n    public User saveUser(User user) {\n        return userRepository.save(user);\n    }\n\n    /**\n     * Obtiene un usuario por su nombre de usuario.\n     *\n     * @param userName El nombre de usuario.\n     * @return Un Optional que contiene el usuario encontrado, o vac\u00edo si no se encuentra.\n     */\n    public Optional&lt;User&gt; getByUserName(String userName) {\n        return userRepository.findByUserName(userName);\n    }\n}\n</code></pre>"},{"location":"4_spring_security/#explicacion_5","title":"Explicaci\u00f3n:","text":"<ul> <li>Gesti\u00f3n de usuarios: Permite obtener y manipular los datos de usuarios.</li> <li>Interacci\u00f3n con la base de datos: Se apoya en <code>UserRepository</code> para realizar operaciones de persistencia.</li> </ul>"},{"location":"4_spring_security/#repositorio-de-usuarios","title":"Repositorio de Usuarios","text":"<p>La interfaz <code>UserRepository</code> define las operaciones de acceso a la base de datos utilizando Spring Data JPA.</p> <pre><code>package com.demospring.security.repository;\n\nimport java.util.Optional;\n\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.stereotype.Repository;\n\nimport com.demospring.security.entity.User;\n\n/**\n * Repositorio para la entidad User.\n * \n * Proporciona m\u00e9todos para realizar operaciones CRUD en la entidad User.\n */\n@Repository\npublic interface UserRepository extends JpaRepository&lt;User, Long&gt; {\n\n    /**\n     * Encuentra un usuario por su identificador.\n     *\n     * @param id El identificador del usuario.\n     * @return El usuario encontrado.\n     */\n    public User findById(long id);\n\n    /**\n     * Encuentra un usuario por su nombre de usuario.\n     *\n     * @param userName El nombre de usuario.\n     * @return Un Optional que contiene el usuario encontrado, o vac\u00edo si no se encuentra.\n     */\n    public Optional&lt;User&gt; findByUserName(String userName);\n\n}\n</code></pre>"},{"location":"4_spring_security/#explicacion_6","title":"Explicaci\u00f3n:","text":"<ul> <li>Persistencia: Proporciona m\u00e9todos autom\u00e1ticos para la manipulaci\u00f3n de la entidad usuario.</li> <li>Uso de JPA: Define operaciones de base de datos de forma declarativa.</li> </ul>"},{"location":"4_spring_security/#contenido-avanzado","title":"Contenido avanzado","text":"<p>En este apartado se ampl\u00edan algunos conceptos avanzados de seguridad en Spring Security y JWT, abordando aspectos adicionales como:</p>"},{"location":"4_spring_security/#seguridad-basada-en-roles-y-permisos","title":"Seguridad basada en roles y permisos","text":"<p>Spring Security permite definir y controlar accesos a nivel de m\u00e9todos mediante anotaciones como:</p> <pre><code>@PreAuthorize(\"hasRole('ADMIN')\")\n@GetMapping(\"/admin\")\npublic String adminAccess() {\n    return \"Acceso permitido solo para administradores.\";\n}\n</code></pre> <p>Con la anotaci\u00f3n <code>@EnableGlobalMethodSecurity(prePostEnabled = true)</code> en la clase de configuraci\u00f3n de seguridad, se pueden proteger m\u00e9todos espec\u00edficos seg\u00fan los roles de los usuarios.</p>"},{"location":"4_spring_security/#seguridad-con-oauth2-y-openid-connect","title":"Seguridad con OAuth2 y OpenID Connect","text":"<p>Adem\u00e1s de JWT, OAuth2 y OpenID Connect son est\u00e1ndares ampliamente utilizados para la autenticaci\u00f3n federada y delegada. Spring Security proporciona integraci\u00f3n con estos est\u00e1ndares mediante la dependencia:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-oauth2-client&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Para configurar un cliente OAuth2 en <code>application.properties</code>:</p> <pre><code>spring.security.oauth2.client.registration.google.client-id=TU_CLIENT_ID\nspring.security.oauth2.client.registration.google.client-secret=TU_CLIENT_SECRET\nspring.security.oauth2.client.registration.google.redirect-uri=http://localhost:8080/login/oauth2/code/google\nspring.security.oauth2.client.registration.google.scope=openid,profile,email\n</code></pre>"},{"location":"4_spring_security/#seguridad-con-cors","title":"Seguridad con CORS","text":"<p>CORS (Cross-Origin Resource Sharing) permite el acceso de aplicaciones web desde dominios distintos. Para habilitar CORS en Spring Security:</p> <pre><code>@Configuration\npublic class CorsConfig {\n\n    @Bean\n    public WebMvcConfigurer corsConfigurer() {\n        return new WebMvcConfigurer() {\n            @Override\n            public void addCorsMappings(CorsRegistry registry) {\n                registry.addMapping(\"/**\")\n                        .allowedOrigins(\"http://localhost:3000\")\n                        .allowedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\")\n                        .allowCredentials(true);\n            }\n        };\n    }\n}\n</code></pre>"},{"location":"4_spring_security/#seguridad-con-cabeceras-http","title":"Seguridad con cabeceras HTTP","text":"<p>Spring Security permite configurar la seguridad mediante cabeceras HTTP, como por ejemplo:</p> <pre><code>http\n    .headers(headers -&gt; headers\n        .frameOptions().disable()  // Permitir iframes desde el mismo origen\n        .contentSecurityPolicy(\"script-src 'self'\")  // Pol\u00edtica de seguridad de contenido\n        .xssProtection().block(true)  // Protecci\u00f3n contra ataques XSS\n    );\n</code></pre>"},{"location":"4_spring_security/#auditoria-y-registro-de-eventos-de-seguridad","title":"Auditor\u00eda y registro de eventos de seguridad","text":"<p>Para registrar eventos de seguridad como inicios de sesi\u00f3n exitosos o fallidos, se puede implementar un auditor personalizado:</p> <pre><code>@Component\npublic class SecurityEventListener {\n\n    private static final Logger logger = LoggerFactory.getLogger(SecurityEventListener.class);\n\n    @EventListener\n    public void onAuthenticationSuccess(AuthenticationSuccessEvent event) {\n        logger.info(\"Inicio de sesi\u00f3n exitoso para el usuario: {}\", event.getAuthentication().getName());\n    }\n\n    @EventListener\n    public void onAuthenticationFailure(AuthenticationFailureBadCredentialsEvent event) {\n        logger.warn(\"Intento de inicio de sesi\u00f3n fallido con usuario: {}\", event.getAuthentication().getName());\n    }\n}\n</code></pre>"},{"location":"4_spring_security/#actividad-practica","title":"Actividad pr\u00e1ctica","text":"<ul> <li>Configurar una aplicaci\u00f3n de prueba que incluya:</li> <li>Protecci\u00f3n de rutas mediante roles y permisos con anotaciones.</li> <li>Integraci\u00f3n con OAuth2 utilizando Google como proveedor de autenticaci\u00f3n.</li> <li>Configuraci\u00f3n de CORS para permitir solicitudes desde un frontend React.</li> <li>Implementaci\u00f3n de auditor\u00eda para registrar eventos de autenticaci\u00f3n.</li> </ul> <p>Este apartado proporciona conocimientos avanzados sobre la seguridad en aplicaciones Spring Boot, ayudando a fortalecer la protecci\u00f3n de los recursos y garantizar la seguridad de los datos.</p>"},{"location":"5_swagger/","title":"Documentaci\u00f3n con Swagger","text":""},{"location":"5_swagger/#capitulo-5-documentacion-con-swagger","title":"Cap\u00edtulo 5: Documentaci\u00f3n con Swagger","text":""},{"location":"5_swagger/#introduccion-a-swagger","title":"Introducci\u00f3n a Swagger","text":"<p>Swagger es una herramienta para documentar y probar APIs RESTful. Proporciona una interfaz de usuario interactiva que permite a los desarrolladores explorar y probar los endpoints de la API de manera sencilla. Swagger facilita la creaci\u00f3n de documentaci\u00f3n detallada y actualizada de las APIs, lo que mejora la comunicaci\u00f3n entre los equipos de desarrollo y otros stakeholders.</p>"},{"location":"5_swagger/#configuracion-de-swagger-en-spring-boot","title":"Configuraci\u00f3n de Swagger en Spring Boot","text":"<p>La configuraci\u00f3n de Swagger se realiza en una clase anotada con <code>@Configuration</code>. Esta clase define un bean <code>Docket</code> que configura Swagger para escanear los controladores y generar la documentaci\u00f3n de la API.</p>"},{"location":"5_swagger/#actividad-practica","title":"Actividad Pr\u00e1ctica","text":"<ul> <li>Configurar Swagger:<ul> <li>Crear una clase de configuraci\u00f3n para Swagger en el paquete <code>config</code>.</li> </ul> </li> </ul> <pre><code>@Configuration\n@EnableSwagger2\npublic class SwaggerConfig {\n    private static final Logger logger = LoggerFactory.getLogger(SwaggerConfig.class);\n\n    @Bean\n    public Docket api() {\n        logger.info(\"Configurando Swagger Docket\");\n        return new Docket(DocumentationType.SWAGGER_2)\n                .select()\n                .apis(RequestHandlerSelectors.basePackage(\"com.demospring.security.controller\"))\n                .paths(PathSelectors.any())\n                .build()\n                .apiInfo(apiInfo());\n    }\n\n    private ApiInfo apiInfo() {\n        logger.debug(\"Configurando ApiInfo\");\n        return new ApiInfoBuilder()\n                .title(\"API de Seguridad\")\n                .description(\"Documentaci\u00f3n de la API de Seguridad con Spring Boot y Swagger\")\n                .version(\"1.0.0\")\n                .build();\n    }\n}\n</code></pre> <p>En esta configuraci\u00f3n:    - La anotaci\u00f3n <code>@EnableSwagger2</code> habilita Swagger en la aplicaci\u00f3n.    - El m\u00e9todo <code>api()</code> define un bean <code>Docket</code> que configura Swagger para escanear los controladores en el paquete <code>com.demospring.security.controller</code>.    - El m\u00e9todo <code>select()</code> permite personalizar qu\u00e9 controladores y rutas se incluir\u00e1n en la documentaci\u00f3n de Swagger.    - <code>apis(RequestHandlerSelectors.basePackage(\"com.demospring.security.controller\"))</code> especifica que solo se escanear\u00e1n los controladores en el paquete <code>com.demospring.security.controller</code>.    - <code>paths(PathSelectors.any())</code> indica que se incluir\u00e1n todas las rutas en la documentaci\u00f3n.    - <code>apiInfo()</code> proporciona informaci\u00f3n adicional sobre la API, como el t\u00edtulo, la descripci\u00f3n y la versi\u00f3n.    - Se utiliza un Logger para registrar eventos importantes durante la configuraci\u00f3n de Swagger.</p> <p>Una vez configurado, Swagger generar\u00e1 autom\u00e1ticamente la documentaci\u00f3n de la API y proporcionar\u00e1 una interfaz de usuario interactiva en la ruta <code>/swagger-ui.html</code>.</p>"},{"location":"5_swagger/#personalizacion-de-swagger-para-mostrar-ejemplos-especificos","title":"Personalizaci\u00f3n de Swagger para Mostrar Ejemplos Espec\u00edficos","text":"<p>Para personalizar Swagger y mostrar ejemplos espec\u00edficos en los endpoints, se pueden utilizar anotaciones como <code>@ApiOperation</code> y <code>@ApiResponses</code> en los controladores. Aqu\u00ed hay un ejemplo:</p> <pre><code>@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    private static final Logger logger = LoggerFactory.getLogger(UserController.class);\n\n    @ApiOperation(value = \"Obtener todos los usuarios\", response = List.class)\n    @ApiResponses(value = {\n        @ApiResponse(code = 200, message = \"Usuarios obtenidos con \u00e9xito\"),\n        @ApiResponse(code = 401, message = \"No autorizado\"),\n        @ApiResponse(code = 403, message = \"Prohibido\"),\n        @ApiResponse(code = 404, message = \"No encontrado\")\n    })\n    @GetMapping\n    public ResponseEntity&lt;List&lt;User&gt;&gt; getAllUsers() {\n        logger.info(\"getAllUsers endpoint llamado\");\n        // ...existing code...\n    }\n\n    @ApiOperation(value = \"Crear un nuevo usuario\")\n    @ApiResponses(value = {\n        @ApiResponse(code = 201, message = \"Usuario creado con \u00e9xito\"),\n        @ApiResponse(code = 400, message = \"Solicitud incorrecta\")\n    })\n    @PostMapping\n    public ResponseEntity&lt;User&gt; createUser(@RequestBody User user) {\n        logger.info(\"createUser endpoint llamado con datos: {}\", user);\n        // ...existing code...\n    }\n}\n</code></pre> <p>En este ejemplo: - <code>@ApiOperation</code> describe la operaci\u00f3n del endpoint. - <code>@ApiResponses</code> define las posibles respuestas del endpoint, incluyendo c\u00f3digos de estado y mensajes. - <code>Logger</code>: Utilizado para registrar eventos importantes y errores en la aplicaci\u00f3n.</p>"},{"location":"5_swagger/#personalizacion-avanzada-de-la-documentacion","title":"Personalizaci\u00f3n Avanzada de la Documentaci\u00f3n","text":"<p>Swagger permite una personalizaci\u00f3n avanzada de la documentaci\u00f3n mediante el uso de anotaciones adicionales y configuraciones espec\u00edficas. Aqu\u00ed hay algunos ejemplos:</p> <ul> <li>Incluir Ejemplos Detallados:   Utiliza la anotaci\u00f3n <code>@ApiModelProperty</code> para incluir ejemplos detallados en los modelos de datos.</li> </ul> <pre><code>public class User {\n    @ApiModelProperty(value = \"ID del usuario\", example = \"1\")\n    private Long id;\n\n    @ApiModelProperty(value = \"Nombre del usuario\", example = \"Juan Perez\")\n    private String name;\n\n    @ApiModelProperty(value = \"Correo electr\u00f3nico del usuario\", example = \"juan.perez@example.com\")\n    private String email;\n\n    // ...existing code...\n}\n</code></pre> <ul> <li>Agregar Descripciones a los Par\u00e1metros:   Utiliza la anotaci\u00f3n <code>@ApiParam</code> para agregar descripciones a los par\u00e1metros de los m\u00e9todos del controlador.</li> </ul> <pre><code>@GetMapping(\"/{id}\")\n@ApiOperation(value = \"Obtener usuario por ID\")\n@ApiResponses(value = {\n    @ApiResponse(code = 200, message = \"Usuario obtenido con \u00e9xito\"),\n    @ApiResponse(code = 404, message = \"Usuario no encontrado\")\n})\npublic ResponseEntity&lt;User&gt; getUserById(\n        @ApiParam(value = \"ID del usuario\", required = true, example = \"1\") @PathVariable Long id) {\n    logger.info(\"getUserById endpoint llamado con ID: {}\", id);\n    // ...existing code...\n}\n</code></pre>"},{"location":"5_swagger/#generar-un-cliente-api-desde-la-documentacion-swagger","title":"Generar un Cliente API desde la Documentaci\u00f3n Swagger","text":"<p>Swagger tambi\u00e9n permite generar clientes API autom\u00e1ticamente desde la documentaci\u00f3n. Aqu\u00ed hay un ejemplo de c\u00f3mo hacerlo:</p> <ul> <li> <p>Acceder a la Interfaz de Usuario de Swagger:</p> <ul> <li>Inicia la aplicaci\u00f3n Spring Boot.</li> <li>Abre un navegador web y navega a <code>http://localhost:8080/swagger-ui.html</code>.</li> </ul> </li> <li> <p>Generar el Cliente API:</p> <ul> <li>En la interfaz de usuario de Swagger, haz clic en el bot\u00f3n \"Generate Client\".</li> <li>Selecciona el lenguaje de programaci\u00f3n deseado (por ejemplo, Java, Python, etc.).</li> <li>Descarga el c\u00f3digo del cliente API generado.</li> </ul> </li> </ul> <p>Este cliente API puede ser utilizado para interactuar con la API documentada sin necesidad de escribir c\u00f3digo adicional para las solicitudes HTTP.</p>"},{"location":"5_swagger/#explicacion-del-codigo","title":"Explicaci\u00f3n del C\u00f3digo","text":"<ul> <li><code>@Configuration</code>: Indica que esta clase es una clase de configuraci\u00f3n de Spring.</li> <li><code>@EnableSwagger2</code>: Habilita Swagger en la aplicaci\u00f3n.</li> <li><code>Docket api()</code>: Define un bean <code>Docket</code> que configura Swagger para escanear los controladores y generar la documentaci\u00f3n de la API.</li> <li><code>select()</code>: Permite personalizar qu\u00e9 controladores y rutas se incluir\u00e1n en la documentaci\u00f3n de Swagger.</li> <li><code>apis(RequestHandlerSelectors.basePackage(\"com.demospring.security.controller\"))</code>: Especifica que solo se escanear\u00e1n los controladores en el paquete <code>com.demospring.security.controller</code>.</li> <li><code>paths(PathSelectors.any())</code>: Indica que se incluir\u00e1n todas las rutas en la documentaci\u00f3n.</li> </ul>"},{"location":"5_swagger/#beneficios-de-usar-swagger","title":"Beneficios de Usar Swagger","text":"<ul> <li>Documentaci\u00f3n Autom\u00e1tica: Swagger genera autom\u00e1ticamente la documentaci\u00f3n de la API basada en los controladores y m\u00e9todos definidos en el c\u00f3digo.</li> <li>Interfaz de Usuario Interactiva: Proporciona una interfaz de usuario interactiva que permite a los desarrolladores explorar y probar los endpoints de la API.</li> <li>Mejora la Comunicaci\u00f3n: Facilita la comunicaci\u00f3n entre los equipos de desarrollo y otros stakeholders al proporcionar una documentaci\u00f3n clara y actualizada de la API.</li> <li>Facilita el Desarrollo: Permite a los desarrolladores probar r\u00e1pidamente los endpoints de la API sin necesidad de escribir c\u00f3digo adicional para las pruebas.</li> </ul>"},{"location":"5_swagger/#actividad-practica_1","title":"Actividad Pr\u00e1ctica","text":"<ul> <li>Acceder a la Interfaz de Usuario de Swagger:<ul> <li>Una vez configurado Swagger, inicia la aplicaci\u00f3n Spring Boot.</li> <li>Abre un navegador web y navega a <code>http://localhost:8080/swagger-ui.html</code>.</li> <li>Explora la interfaz de usuario de Swagger para ver y probar los endpoints de la API.</li> </ul> </li> </ul>"},{"location":"6_servcios_red/","title":"Implementaci\u00f3n de Servicios en Red","text":""},{"location":"6_servcios_red/#capitulo-6-implementacion-de-servicios-en-red","title":"Cap\u00edtulo 6: Implementaci\u00f3n de Servicios en Red","text":""},{"location":"6_servcios_red/#introduccion-a-los-servicios-en-red","title":"Introducci\u00f3n a los Servicios en Red","text":"<p>Los servicios en red permiten la comunicaci\u00f3n entre aplicaciones a trav\u00e9s de la red. Estos servicios son esenciales para la arquitectura de microservicios y aplicaciones distribuidas, donde diferentes componentes de la aplicaci\u00f3n necesitan comunicarse entre s\u00ed.</p>"},{"location":"6_servcios_red/#implementacion-de-un-servicio-de-envio-de-correos-electronicos","title":"Implementaci\u00f3n de un Servicio de Env\u00edo de Correos Electr\u00f3nicos","text":"<p>La implementaci\u00f3n de un servicio de env\u00edo de correos electr\u00f3nicos se realiza utilizando Spring Boot y JavaMailSender. Este servicio permite enviar correos electr\u00f3nicos desde la aplicaci\u00f3n, lo cual es \u00fatil para notificaciones, confirmaciones de registro, restablecimiento de contrase\u00f1as, entre otros.</p>"},{"location":"6_servcios_red/#actividad-practica","title":"Actividad Pr\u00e1ctica","text":"<ul> <li> <p>Configurar las Dependencias de JavaMailSender:</p> <ul> <li>A\u00f1adir las dependencias necesarias en el archivo <code>pom.xml</code>: <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre></li> </ul> </li> <li> <p>Configurar las Propiedades del Correo Electr\u00f3nico:</p> <ul> <li>Configurar las propiedades del correo electr\u00f3nico en el archivo <code>application.properties</code>: <pre><code>spring.mail.host=smtp.mailtrap.io\nspring.mail.port=2525\nspring.mail.username=your-mailtrap-username\nspring.mail.password=your-mailtrap-password\nspring.mail.properties.mail.smtp.auth=true\nspring.mail.properties.mail.smtp.starttls.enable=true\n</code></pre></li> </ul> </li> <li> <p>Crear el Servicio de Env\u00edo de Correos Electr\u00f3nicos:</p> <ul> <li>Crear una clase <code>EmailService</code> en el paquete <code>service</code>: <pre><code>@Service\npublic class EmailService {\n    private static final Logger logger = LoggerFactory.getLogger(EmailService.class);\n\n    @Autowired\n    private JavaMailSender mailSender;\n\n    public void sendEmail(String to, String subject, String text) {\n        try {\n            logger.info(\"Enviando correo a: {}\", to);\n            SimpleMailMessage message = new SimpleMailMessage();\n            message.setTo(to);\n            message.setSubject(subject);\n            message.setText(text);\n            mailSender.send(message);\n            logger.info(\"Correo enviado a: {}\", to);\n        } catch (MailException e) {\n            logger.error(\"Error al enviar el correo: {}\", e.getMessage());\n        }\n    }\n\n    public void sendEmailWithAttachment(String to, String subject, String text, String pathToAttachment) {\n        try {\n            logger.info(\"Enviando correo con adjunto a: {}\", to);\n            MimeMessage message = mailSender.createMimeMessage();\n            MimeMessageHelper helper = new MimeMessageHelper(message, true);\n\n            helper.setTo(to);\n            helper.setSubject(subject);\n            helper.setText(text);\n\n            FileSystemResource file = new FileSystemResource(new File(pathToAttachment));\n            helper.addAttachment(\"Adjunto\", file);\n\n            mailSender.send(message);\n            logger.info(\"Correo con adjunto enviado a: {}\", to);\n        } catch (MessagingException | MailException e) {\n            logger.error(\"Error al enviar el correo con adjunto: {}\", e.getMessage());\n        }\n    }\n}\n</code></pre></li> </ul> </li> </ul>"},{"location":"6_servcios_red/#explicacion-del-codigo","title":"Explicaci\u00f3n del C\u00f3digo","text":"<ul> <li><code>@Service</code>: Indica que esta clase es un servicio de Spring.</li> <li><code>JavaMailSender</code>: Es una interfaz proporcionada por Spring Boot para enviar correos electr\u00f3nicos.</li> <li><code>sendEmail(String to, String subject, String text)</code>: M\u00e9todo que env\u00eda un correo electr\u00f3nico con el destinatario, asunto y texto especificados. Maneja errores utilizando un bloque <code>try-catch</code>.</li> <li><code>sendEmailWithAttachment(String to, String subject, String text, String pathToAttachment)</code>: M\u00e9todo que env\u00eda un correo electr\u00f3nico con un archivo adjunto. Utiliza <code>MimeMessageHelper</code> para configurar el mensaje con el archivo adjunto.</li> </ul>"},{"location":"6_servcios_red/#uso-de-mailtrap-para-pruebas-de-correo-electronico","title":"Uso de Mailtrap para Pruebas de Correo Electr\u00f3nico","text":"<p>Mailtrap es una herramienta que permite probar el env\u00edo de correos electr\u00f3nicos sin necesidad de configurar un servidor SMTP real. Aqu\u00ed se explica c\u00f3mo configurarlo:</p> <ul> <li> <p>Crear una Cuenta en Mailtrap:</p> <ul> <li>Reg\u00edstrate en Mailtrap y crea un inbox.</li> </ul> </li> <li> <p>Obtener las Credenciales SMTP:</p> <ul> <li>En el dashboard de Mailtrap, selecciona el inbox y copia las credenciales SMTP (host, puerto, nombre de usuario y contrase\u00f1a).</li> </ul> </li> <li> <p>Configurar las Propiedades del Correo Electr\u00f3nico:</p> <ul> <li>Configura las propiedades del correo electr\u00f3nico en el archivo <code>application.properties</code> utilizando las credenciales de Mailtrap: <pre><code>spring.mail.host=smtp.mailtrap.io\nspring.mail.port=2525\nspring.mail.username=your-mailtrap-username\nspring.mail.password=your-mailtrap-password\nspring.mail.properties.mail.smtp.auth=true\nspring.mail.properties.mail.smtp.starttls.enable=true\n</code></pre></li> </ul> </li> </ul>"},{"location":"6_servcios_red/#beneficios-de-usar-javamailsender","title":"Beneficios de Usar JavaMailSender","text":"<ul> <li>Simplicidad: JavaMailSender simplifica el env\u00edo de correos electr\u00f3nicos al proporcionar una API f\u00e1cil de usar.</li> <li>Configuraci\u00f3n Flexible: Permite configurar diversas propiedades del correo electr\u00f3nico, como el servidor SMTP, puerto, autenticaci\u00f3n, entre otros.</li> <li>Integraci\u00f3n con Spring Boot: Se integra f\u00e1cilmente con aplicaciones Spring Boot, lo que facilita su configuraci\u00f3n y uso.</li> </ul>"},{"location":"6_servcios_red/#actividad-practica_1","title":"Actividad Pr\u00e1ctica","text":"<ul> <li> <p>Enviar un Correo Electr\u00f3nico de Prueba:</p> <ul> <li>Crear un controlador REST para probar el env\u00edo de correos electr\u00f3nicos: <pre><code>@RestController\n@RequestMapping(\"/api/email\")\npublic class EmailController {\n    @Autowired\n    private EmailService emailService;\n\n    @PostMapping(\"/send\")\n    public ResponseEntity&lt;String&gt; sendEmail(@RequestParam String to, @RequestParam String subject, @RequestParam String text) {\n        emailService.sendEmail(to, subject, text);\n        return ResponseEntity.ok(\"Email sent successfully\");\n    }\n\n    @PostMapping(\"/sendWithAttachment\")\n    public ResponseEntity&lt;String&gt; sendEmailWithAttachment(@RequestParam String to, @RequestParam String subject, @RequestParam String text, @RequestParam String pathToAttachment) {\n        emailService.sendEmailWithAttachment(to, subject, text, pathToAttachment);\n        return ResponseEntity.ok(\"Email with attachment sent successfully\");\n    }\n}\n</code></pre></li> </ul> </li> <li> <p>Probar el Env\u00edo de Correos Electr\u00f3nicos:</p> <ul> <li>Iniciar la aplicaci\u00f3n Spring Boot.</li> <li>Utilizar una herramienta como Postman para enviar una solicitud POST a <code>http://localhost:8080/api/email/send</code> con los par\u00e1metros <code>to</code>, <code>subject</code> y <code>text</code>.</li> <li>Verificar que el correo electr\u00f3nico se env\u00eda correctamente.</li> </ul> </li> <li> <p>Probar el Env\u00edo de Correos Electr\u00f3nicos con Archivos Adjuntos:</p> <ul> <li>Utilizar una herramienta como Postman para enviar una solicitud POST a <code>http://localhost:8080/api/email/sendWithAttachment</code> con los par\u00e1metros <code>to</code>, <code>subject</code>, <code>text</code> y <code>pathToAttachment</code>.</li> <li>Verificar que el correo electr\u00f3nico con el archivo adjunto se env\u00eda correctamente.</li> </ul> </li> </ul>"},{"location":"6_servcios_red/#manejo-de-errores-comunes","title":"Manejo de Errores Comunes","text":"<p>Es importante manejar errores comunes al enviar correos electr\u00f3nicos, como problemas de conexi\u00f3n o autenticaci\u00f3n. Aqu\u00ed hay un ejemplo de c\u00f3mo manejar estos errores en el servicio de env\u00edo de correos:</p> <pre><code>@Service\npublic class EmailService {\n    private static final Logger logger = LoggerFactory.getLogger(EmailService.class);\n\n    @Autowired\n    private JavaMailSender mailSender;\n\n    public void sendEmail(String to, String subject, String text) {\n        try {\n            logger.info(\"Enviando correo a: {}\", to);\n            SimpleMailMessage message = new SimpleMailMessage();\n            message.setTo(to);\n            message.setSubject(subject);\n            message.setText(text);\n            mailSender.send(message);\n            logger.info(\"Correo enviado a: {}\", to);\n        } catch (MailAuthenticationException e) {\n            logger.error(\"Error de autenticaci\u00f3n: {}\", e.getMessage());\n        } catch (MailSendException e) {\n            logger.error(\"Error al enviar el correo: {}\", e.getMessage());\n        } catch (MailException e) {\n            logger.error(\"Error general de correo: {}\", e.getMessage());\n        }\n    }\n\n    public void sendEmailWithAttachment(String to, String subject, String text, String pathToAttachment) {\n        try {\n            logger.info(\"Enviando correo con adjunto a: {}\", to);\n            MimeMessage message = mailSender.createMimeMessage();\n            MimeMessageHelper helper = new MimeMessageHelper(message, true);\n\n            helper.setTo(to);\n            helper.setSubject(subject);\n            helper.setText(text);\n\n            FileSystemResource file = new FileSystemResource(new File(pathToAttachment));\n            helper.addAttachment(\"Adjunto\", file);\n\n            mailSender.send(message);\n            logger.info(\"Correo con adjunto enviado a: {}\", to);\n        } catch (MessagingException | MailException e) {\n            logger.error(\"Error al enviar el correo con adjunto: {}\", e.getMessage());\n        }\n    }\n}\n</code></pre> <p>En este ejemplo, se manejan diferentes tipos de excepciones de correo para proporcionar mensajes de error m\u00e1s espec\u00edficos y se utiliza un Logger para registrar eventos importantes.</p>"},{"location":"7_test/","title":"6. Pruebas y Depuraci\u00f3n","text":""},{"location":"7_test/#introduccion-a-las-pruebas-en-spring-boot","title":"Introducci\u00f3n a las Pruebas en Spring Boot","text":"<p>Las pruebas son una parte crucial del ciclo de desarrollo de software. Aseguran que el c\u00f3digo funcione como se espera y ayudan a identificar problemas antes de que lleguen a producci\u00f3n. En el ecosistema de Spring Boot, las herramientas m\u00e1s comunes para realizar pruebas son JUnit, Mockito y Spring Boot Test.</p>"},{"location":"7_test/#pruebas-unitarias-y-de-integracion","title":"Pruebas Unitarias y de Integraci\u00f3n","text":""},{"location":"7_test/#pruebas-unitarias","title":"Pruebas Unitarias","text":"<p>Las pruebas unitarias son esenciales para asegurar que cada componente de la aplicaci\u00f3n funcione correctamente de manera aislada. En aplicaciones Spring Boot, JUnit y Mockito son herramientas populares para escribir y ejecutar pruebas unitarias.</p>"},{"location":"7_test/#configuracion-de-junit-y-mockito","title":"Configuraci\u00f3n de JUnit y Mockito","text":"<p>Para comenzar, aseg\u00farate de tener las dependencias necesarias en tu archivo <code>pom.xml</code>:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.mockito&lt;/groupId&gt;\n    &lt;artifactId&gt;mockito-core&lt;/artifactId&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"7_test/#ejemplo-de-prueba-unitaria","title":"Ejemplo de Prueba Unitaria","text":"<pre><code>import static org.mockito.Mockito.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\nimport org.junit.jupiter.api.extension.ExtendWith;\n\n@ExtendWith(MockitoExtension.class)\npublic class MiServicioTest {\n\n    @Mock\n    private MiRepositorio miRepositorio;\n\n    @InjectMocks\n    private MiServicio miServicio;\n\n    @Test\n    public void testObtenerDatos() {\n        when(miRepositorio.obtenerDatos()).thenReturn(\"datos de prueba\");\n\n        String resultado = miServicio.obtenerDatos();\n\n        assertEquals(\"datos de prueba\", resultado);\n    }\n}\n</code></pre>"},{"location":"7_test/#pruebas-de-integracion","title":"Pruebas de Integraci\u00f3n","text":"<p>Las pruebas de integraci\u00f3n verifican que diferentes partes de la aplicaci\u00f3n funcionen juntas correctamente. En Spring Boot, estas pruebas suelen involucrar el contexto de la aplicaci\u00f3n completo.</p>"},{"location":"7_test/#configuracion-para-pruebas-de-integracion","title":"Configuraci\u00f3n para Pruebas de Integraci\u00f3n","text":"<p>Para realizar pruebas de integraci\u00f3n, puedes utilizar bases de datos en memoria como H2. Aseg\u00farate de tener la dependencia en tu archivo <code>pom.xml</code>:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.h2database&lt;/groupId&gt;\n    &lt;artifactId&gt;h2&lt;/artifactId&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"7_test/#ejemplo-de-prueba-de-integracion","title":"Ejemplo de Prueba de Integraci\u00f3n","text":"<pre><code>import org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit4.SpringRunner;\nimport org.junit.jupiter.api.Test;\nimport org.junit.runner.RunWith;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class MiAplicacionTests {\n\n    @Autowired\n    private MiServicio miServicio;\n\n    @Test\n    public void contextLoads() {\n        assertThat(miServicio).isNotNull();\n    }\n}\n</code></pre>"},{"location":"7_test/#ejecucion-de-pruebas","title":"Ejecuci\u00f3n de Pruebas","text":""},{"location":"7_test/#integracion-con-herramientas-de-cicd","title":"Integraci\u00f3n con Herramientas de CI/CD","text":"<p>Para integrar las pruebas con herramientas de CI/CD, aseg\u00farate de que tu pipeline ejecute los tests autom\u00e1ticamente. Por ejemplo, en un archivo de configuraci\u00f3n de Jenkins:</p> <pre><code>pipeline {\n    agent any\n    stages {\n        stage('Test') {\n            steps {\n                sh './mvnw test'\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"7_test/#reportes-de-pruebas","title":"Reportes de Pruebas","text":"<p>Los reportes de pruebas son esenciales para entender el estado de las pruebas. Puedes configurar Maven Surefire Plugin para generar reportes:</p> <pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n    &lt;version&gt;2.22.2&lt;/version&gt;\n    &lt;configuration&gt;\n        &lt;reportsDirectory&gt;${project.build.directory}/surefire-reports&lt;/reportsDirectory&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre>"},{"location":"7_test/#depuracion-y-monitoreo","title":"Depuraci\u00f3n y Monitoreo","text":""},{"location":"7_test/#depuracion","title":"Depuraci\u00f3n","text":"<p>La depuraci\u00f3n es una parte crucial del desarrollo de software. Spring Boot facilita la depuraci\u00f3n con su soporte para logs y herramientas de depuraci\u00f3n.</p>"},{"location":"7_test/#configuracion-de-logs","title":"Configuraci\u00f3n de Logs","text":"<p>Spring Boot utiliza <code>Logback</code> como el motor de logging por defecto. Puedes configurar los logs en el archivo <code>application.properties</code>:</p> <pre><code>logging.level.org.springframework=DEBUG\nlogging.level.com.miapp=DEBUG\n</code></pre>"},{"location":"7_test/#monitoreo","title":"Monitoreo","text":"<p>El monitoreo de aplicaciones en producci\u00f3n es vital para mantener el rendimiento y la disponibilidad. Spring Boot Actuator proporciona endpoints para monitorear y gestionar la aplicaci\u00f3n.</p>"},{"location":"7_test/#configuracion-de-spring-boot-actuator","title":"Configuraci\u00f3n de Spring Boot Actuator","text":"<p>A\u00f1ade la dependencia en tu <code>pom.xml</code>:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"7_test/#endpoints-de-actuator","title":"Endpoints de Actuator","text":"<p>Actuator expone varios endpoints \u00fatiles, como <code>/actuator/health</code> y <code>/actuator/metrics</code>. Puedes configurarlos en <code>application.properties</code>:</p> <pre><code>management.endpoints.web.exposure.include=health,info,metrics\n</code></pre>"},{"location":"7_test/#ejemplo-de-uso-de-actuator","title":"Ejemplo de Uso de Actuator","text":"<p>Accede a los endpoints de Actuator para obtener informaci\u00f3n sobre el estado de la aplicaci\u00f3n:</p> <pre><code>curl http://localhost:8080/actuator/health\ncurl http://localhost:8080/actuator/metrics\n</code></pre> <p>Estos endpoints proporcionan informaci\u00f3n valiosa para monitorear y mantener la salud de tu aplicaci\u00f3n Spring Boot en producci\u00f3n.</p>"},{"location":"8_distribuida/","title":"8. Introducci\u00f3n a la programaci\u00f3n distribuida","text":""},{"location":"8_distribuida/#objetivo","title":"Objetivo","text":"<p>Introducir conceptos de programaci\u00f3n distribuida y su implementaci\u00f3n en Spring Boot.</p>"},{"location":"8_distribuida/#conceptos-basicos","title":"Conceptos B\u00e1sicos","text":"<p>La programaci\u00f3n paralela se enfoca en ejecutar m\u00faltiples tareas simult\u00e1neamente en un solo sistema, utilizando m\u00faltiples n\u00facleos de CPU. Un ejemplo de esto es el procesamiento de im\u00e1genes, donde cada n\u00facleo procesa una parte de la imagen.</p> <p>Por otro lado, la programaci\u00f3n distribuida implica m\u00faltiples sistemas trabajando juntos en una red para completar tareas. Un ejemplo de esto es un motor de b\u00fasqueda en l\u00ednea, donde diferentes servidores indexan diferentes partes de la web para proporcionar resultados de b\u00fasqueda r\u00e1pidos y relevantes.</p> <p>Ventajas de los sistemas distribuidos incluyen la escalabilidad, que es la capacidad de a\u00f1adir m\u00e1s nodos para manejar m\u00e1s carga. Por ejemplo, en un sistema de comercio electr\u00f3nico, se pueden a\u00f1adir m\u00e1s servidores para manejar m\u00e1s usuarios. Tambi\u00e9n ofrecen tolerancia a fallos, ya que si un nodo falla, otros pueden continuar el trabajo. Por ejemplo, si un servidor se cae, otros servidores pueden tomar su lugar. Adem\u00e1s, ofrecen flexibilidad, permitiendo que diferentes nodos ejecuten diferentes tareas. Por ejemplo, un nodo puede manejar la autenticaci\u00f3n de usuarios mientras otro maneja las transacciones.</p> <p>Sin embargo, los sistemas distribuidos tambi\u00e9n presentan desaf\u00edos. La gesti\u00f3n de m\u00faltiples nodos y su comunicaci\u00f3n puede ser compleja, por ejemplo, asegurar que todos los nodos est\u00e9n sincronizados y se comuniquen correctamente. La latencia de red, o el tiempo de retraso en la comunicaci\u00f3n entre nodos, puede ser un problema, especialmente en la comunicaci\u00f3n entre servidores en diferentes ubicaciones geogr\u00e1ficas. Finalmente, asegurar la consistencia de datos, es decir, que todos los nodos tengan la misma informaci\u00f3n, puede ser complicado. Por ejemplo, si un usuario actualiza su perfil, todos los nodos deben tener la informaci\u00f3n actualizada.</p>"},{"location":"8_distribuida/#microservicios-con-spring-boot","title":"Microservicios con Spring Boot","text":"<p>Spring Cloud proporciona herramientas para construir aplicaciones distribuidas y microservicios, facilitando la configuraci\u00f3n, descubrimiento, balanceo de carga, y m\u00e1s. Por ejemplo, Spring Cloud Config para la gesti\u00f3n de configuraci\u00f3n, Spring Cloud Netflix para el descubrimiento de servicios, y Spring Cloud Gateway para el enrutamiento de solicitudes.</p> <p>Cada microservicio es una aplicaci\u00f3n Spring Boot independiente que se comunica con otros servicios a trav\u00e9s de APIs REST. Esto permite que cada servicio sea desarrollado, desplegado y escalado de manera independiente.</p> <p>Ejemplo b\u00e1sico de un microservicio: <pre><code>@SpringBootApplication\npublic class ServicioClienteApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ServicioClienteApplication.class, args);\n    }\n}\n\n@RestController\n@RequestMapping(\"/cliente\")\npublic class ClienteController {\n    @GetMapping\n    public String getCliente() {\n        return \"Cliente 1\";\n    }\n}\n</code></pre></p>"},{"location":"8_distribuida/#comunicacion-entre-microservicios","title":"Comunicaci\u00f3n entre Microservicios","text":"<p>RestTemplate es una clase de Spring para hacer llamadas HTTP sincr\u00f3nicas. Es \u00fatil para realizar solicitudes HTTP simples y directas.</p> <p>Feign es un cliente HTTP declarativo que facilita la comunicaci\u00f3n entre microservicios. Permite definir interfaces y anotarlas para especificar las solicitudes HTTP.</p> <p>Ejemplo de uso de RestTemplate: <pre><code>@RestController\npublic class ClienteController {\n    @Autowired\n    private RestTemplate restTemplate;\n\n    @GetMapping(\"/cliente\")\n    public String getCliente() {\n        return restTemplate.getForObject(\"http://servicio-cliente/cliente\", String.class);\n    }\n}\n</code></pre></p> <p>Ejemplo de uso de Feign: <pre><code>@FeignClient(name = \"servicio-cliente\")\npublic interface ClienteFeignClient {\n    @GetMapping(\"/cliente\")\n    String getCliente();\n}\n\n@RestController\npublic class ClienteController {\n    @Autowired\n    private ClienteFeignClient clienteFeignClient;\n\n    @GetMapping(\"/cliente\")\n    public String getCliente() {\n        return clienteFeignClient.getCliente();\n    }\n}\n</code></pre></p> <p>Ribbon es una biblioteca de balanceo de carga cliente que distribuye las solicitudes entre m\u00faltiples instancias de un servicio. Esto ayuda a distribuir la carga de trabajo y mejorar la disponibilidad del servicio.</p> <p>Spring Cloud LoadBalancer es una alternativa m\u00e1s reciente y ligera que proporciona funcionalidad similar.</p> <p>Ejemplo de configuraci\u00f3n de Ribbon: <pre><code>@Bean\n@LoadBalanced\npublic RestTemplate restTemplate() {\n    return new RestTemplate();\n}\n</code></pre></p>"},{"location":"8_distribuida/#gestion-de-configuracion","title":"Gesti\u00f3n de Configuraci\u00f3n","text":"<p>Spring Cloud Config Server permite centralizar la configuraci\u00f3n de m\u00faltiples aplicaciones, almacenando las configuraciones en un repositorio Git. Esto facilita la gesti\u00f3n de configuraciones y asegura que todas las aplicaciones utilicen la misma configuraci\u00f3n.</p> <p>Ejemplo de configuraci\u00f3n de Spring Cloud Config Server: <pre><code># application.yml en Config Server\nspring:\n  cloud:\n    config:\n      server:\n        git:\n          uri: https://github.com/tu-repo/config-repo\n</code></pre></p> <p>Uso de perfiles para gestionar configuraciones espec\u00edficas de entornos (dev, prod, etc.). Esto permite tener diferentes configuraciones para diferentes entornos sin necesidad de cambiar el c\u00f3digo.</p> <p>Ejemplo de configuraci\u00f3n de perfiles: <pre><code># application-dev.yml\nserver:\n  port: 8081\n</code></pre></p>"},{"location":"8_distribuida/#pruebas-de-un-sistema-distribuido","title":"Pruebas de un Sistema Distribuido","text":"<p>Uso de herramientas como WireMock para simular servicios externos y probar la interacci\u00f3n entre microservicios. Esto permite probar c\u00f3mo se comportan los servicios cuando interact\u00faan con otros servicios.</p> <p>Ejemplo de prueba con WireMock: <pre><code>@Test\npublic void testClienteService() {\n    stubFor(get(urlEqualTo(\"/cliente\"))\n        .willReturn(aResponse()\n            .withStatus(200)\n            .withBody(\"Cliente 1\")));\n\n    String response = restTemplate.getForObject(\"http://localhost:8080/cliente\", String.class);\n    assertEquals(\"Cliente 1\", response);\n}\n</code></pre></p> <p>Implementaci\u00f3n de pruebas de contrato para garantizar que los servicios se comuniquen correctamente y mantengan la consistencia de datos. Esto asegura que los servicios cumplan con los contratos definidos y se comporten como se espera.</p> <p>Ejemplo de prueba de contrato: <pre><code>@SpringBootTest\npublic class ClienteContractTest {\n    @Autowired\n    private MockMvc mockMvc;\n\n    @Test\n    public void validateClienteContract() throws Exception {\n        mockMvc.perform(get(\"/cliente\"))\n            .andExpect(status().isOk())\n            .andExpect(content().string(\"Cliente 1\"));\n    }\n}\n</code></pre></p>"},{"location":"9_despliegue/","title":"Despliegue de Aplicaciones Spring Boot en Entornos de Producci\u00f3n","text":""},{"location":"9_despliegue/#preparacion-para-el-despliegue","title":"Preparaci\u00f3n para el Despliegue","text":""},{"location":"9_despliegue/#construccion-del-paquete-jar-o-war","title":"Construcci\u00f3n del paquete (JAR o WAR)","text":"<p>Para desplegar una aplicaci\u00f3n Spring Boot, primero necesitas construir el paquete de tu aplicaci\u00f3n. Esto puede ser un archivo JAR (Java ARchive) o un archivo WAR (Web Application Archive). Utiliza herramientas de construcci\u00f3n como Maven o Gradle para este prop\u00f3sito.</p> <p>Con Maven, puedes construir el paquete ejecutando el siguiente comando en la ra\u00edz de tu proyecto: <pre><code>mvn clean package\n</code></pre> Este comando limpiar\u00e1 cualquier construcci\u00f3n previa y empaquetar\u00e1 tu aplicaci\u00f3n en un archivo JAR o WAR, dependiendo de tu configuraci\u00f3n.</p> <p>Con Gradle, el comando equivalente es: <pre><code>./gradlew build\n</code></pre> Este comando tambi\u00e9n limpiar\u00e1 y construir\u00e1 tu proyecto, generando el archivo JAR o WAR en el directorio <code>build/libs</code>.</p>"},{"location":"9_despliegue/#configuracion-para-produccion-propiedades-perfiles-y-logs","title":"Configuraci\u00f3n para producci\u00f3n: propiedades, perfiles y logs","text":"<p>Es crucial configurar tu aplicaci\u00f3n adecuadamente para el entorno de producci\u00f3n. Esto incluye la configuraci\u00f3n de propiedades, perfiles y logs.</p> <ul> <li> <p>Propiedades: Crea un archivo <code>application-prod.properties</code> en el directorio <code>src/main/resources</code>. Este archivo contendr\u00e1 las propiedades espec\u00edficas para el entorno de producci\u00f3n, como configuraciones de base de datos, URLs de servicios externos, etc.</p> </li> <li> <p>Perfiles: Utiliza perfiles para separar las configuraciones de desarrollo y producci\u00f3n. Puedes activar el perfil de producci\u00f3n a\u00f1adiendo el par\u00e1metro <code>--spring.profiles.active=prod</code> al comando de ejecuci\u00f3n de tu aplicaci\u00f3n.</p> </li> <li> <p>Logs: Configura los logs para producci\u00f3n asegur\u00e1ndote de que se capturen errores y eventos importantes. Puedes configurar el nivel de log y los appenders en el archivo <code>logback-spring.xml</code> o <code>application-prod.properties</code>.</p> </li> </ul>"},{"location":"9_despliegue/#despliegue-en-servidores-locales","title":"Despliegue en Servidores Locales","text":""},{"location":"9_despliegue/#uso-de-apache-tomcat-o-jetty","title":"Uso de Apache Tomcat o Jetty","text":"<p>Si decides empaquetar tu aplicaci\u00f3n como un archivo WAR, puedes desplegarla en servidores de aplicaciones como Apache Tomcat o Jetty.</p> <ul> <li>Empaqueta tu aplicaci\u00f3n como un archivo WAR utilizando Maven o Gradle.</li> <li>Copia el archivo WAR generado en el directorio <code>webapps</code> de tu instalaci\u00f3n de Tomcat o Jetty.</li> <li>Inicia el servidor y tu aplicaci\u00f3n estar\u00e1 disponible en el contexto configurado.</li> </ul>"},{"location":"9_despliegue/#ejecucion-como-aplicacion-standalone","title":"Ejecuci\u00f3n como aplicaci\u00f3n standalone","text":"<p>Otra opci\u00f3n es empaquetar tu aplicaci\u00f3n como un archivo JAR y ejecutarla como una aplicaci\u00f3n standalone.</p> <ol> <li>Empaqueta tu aplicaci\u00f3n como un archivo JAR utilizando Maven o Gradle.</li> <li>Ejecuta el archivo JAR usando el siguiente comando: <pre><code>java -jar tu-aplicacion.jar\n</code></pre> Esto iniciar\u00e1 un servidor embebido (como Tomcat o Jetty) y tu aplicaci\u00f3n estar\u00e1 disponible en el puerto configurado (por defecto, el puerto 8080).</li> </ol>"},{"location":"9_despliegue/#despliegue-en-la-nube","title":"Despliegue en la Nube","text":""},{"location":"9_despliegue/#introduccion-a-plataformas-cloud-aws-gcp","title":"Introducci\u00f3n a plataformas cloud (AWS, GCP)","text":"<p>Desplegar aplicaciones en la nube ofrece ventajas como escalabilidad, alta disponibilidad y gesti\u00f3n simplificada. Algunas de las plataformas cloud m\u00e1s populares son AWS y GCP.</p> <ul> <li>AWS (Amazon Web Services): Ofrece una amplia gama de servicios para el despliegue y escalado de aplicaciones, incluyendo EC2, Elastic Beanstalk, y RDS.</li> <li>GCP (Google Cloud Platform): Proporciona herramientas y servicios para desplegar aplicaciones en la nube, como Google App Engine, Kubernetes Engine, y Cloud SQL.</li> </ul>"},{"location":"9_despliegue/#contenedores-con-docker","title":"Contenedores con Docker","text":""},{"location":"9_despliegue/#crear-un-dockerfile-para-la-aplicacion","title":"Crear un Dockerfile para la aplicaci\u00f3n","text":"<p>Docker permite empaquetar tu aplicaci\u00f3n y sus dependencias en un contenedor, asegurando que se ejecute de manera consistente en cualquier entorno. Para crear un contenedor Docker para tu aplicaci\u00f3n Spring Boot, necesitas definir un Dockerfile.</p> <p>Ejemplo b\u00e1sico de Dockerfile: <pre><code>FROM openjdk:11-jre-slim\nCOPY target/tu-aplicacion.jar app.jar\nENTRYPOINT [\"java\", \"-jar\", \"/app.jar\"]\n</code></pre> Este Dockerfile utiliza una imagen base de OpenJDK 11, copia el archivo JAR de tu aplicaci\u00f3n en el contenedor y define el comando de entrada para ejecutar la aplicaci\u00f3n.</p>"},{"location":"9_despliegue/#despliegue-de-contenedores-con-docker-compose","title":"Despliegue de contenedores con Docker Compose","text":"<p>Docker Compose permite definir y ejecutar aplicaciones multi-contenedor. Puedes definir un archivo <code>docker-compose.yml</code> para gestionar m\u00faltiples contenedores.</p> <p>Ejemplo b\u00e1sico de <code>docker-compose.yml</code>: <pre><code>version: '3'\nservices:\n  app:\n    image: tu-imagen\n    ports:\n      - \"8080:8080\"\n</code></pre> Este archivo define un servicio llamado <code>app</code> que utiliza la imagen de tu aplicaci\u00f3n y expone el puerto 8080.</p>"},{"location":"9_despliegue/#monitorizacion-y-escalabilidad","title":"Monitorizaci\u00f3n y Escalabilidad","text":""},{"location":"9_despliegue/#herramientas-como-spring-boot-actuator","title":"Herramientas como Spring Boot Actuator","text":"<p>Spring Boot Actuator a\u00f1ade endpoints de monitorizaci\u00f3n a tu aplicaci\u00f3n, permiti\u00e9ndote obtener informaci\u00f3n sobre su estado y m\u00e9tricas. Para habilitar Actuator, a\u00f1ade la dependencia en tu <code>pom.xml</code> o <code>build.gradle</code>.</p> <p>Ejemplo de configuraci\u00f3n en <code>pom.xml</code>: <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> Configura los endpoints en tu archivo <code>application.properties</code> o <code>application.yml</code>. Por ejemplo, para habilitar el endpoint de salud: <pre><code>management.endpoints.web.exposure.include=health\n</code></pre> Accede al endpoint <code>/actuator/health</code> para verificar el estado de la aplicaci\u00f3n.</p>"},{"location":"9_despliegue/#escalado-horizontal-y-vertical","title":"Escalado horizontal y vertical","text":"<p>El escalado es crucial para manejar el aumento de tr\u00e1fico y mejorar el rendimiento de tu aplicaci\u00f3n.</p> <ul> <li>Escalado horizontal: A\u00f1ade m\u00e1s instancias de tu aplicaci\u00f3n para distribuir la carga. Esto se puede lograr f\u00e1cilmente en plataformas cloud y con herramientas de orquestaci\u00f3n de contenedores como Kubernetes.</li> <li>Escalado vertical: Aumenta los recursos (CPU, memoria) de la instancia existente para mejorar el rendimiento. Esto puede ser \u00fatil para aplicaciones que requieren m\u00e1s recursos en lugar de m\u00e1s instancias.</li> </ul> <p>Implementar estrategias de escalado adecuadas asegurar\u00e1 que tu aplicaci\u00f3n pueda manejar el crecimiento y mantener un rendimiento \u00f3ptimo.</p>"}]}